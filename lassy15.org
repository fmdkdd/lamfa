#+PROPERTY: header-args :results output :noweb yes
# C-c C-v C-b org-babel-execute-buffer
# C-c C-x C-M-v org-redisplay-inline-images

#+NAME: svg
#+BEGIN_SRC js
  function toMarkup(obj, open, close, attr) {
    if (typeof obj !== 'object') return obj.toString();

    let tagName = obj.t;
    let attrs = Object.getOwnPropertyNames(obj.attrs).map(n => attr(n, obj.attrs[n]));
    let content = obj.children.map(o => toMarkup(o, open, close, attr)).join('');
    return open(tagName, attrs) + content + close(tagName);
  }

  function toSVG(obj) {
    function openSVG(tagName, attrs) { return '<' + (tagName + ' ' + attrs.join(' ')).trim() + '>' }
    function closeSVG(tagName) { return '</' + tagName + '>' }
    function attrSVG(k, v) { return k  + '="' + v + '"' }
    return toMarkup(obj, openSVG, closeSVG, attrSVG);
  }

  function t(tagName, ...args) {
    let o = {
      t: tagName,
      attrs: Object.create(null),
      a(k, v) { o.attrs[k] = v; return o },
      children: args,
    };
    let shortcuts = ['width', 'height', 'fill', 'stroke', 'cx', 'cy', 'r',
                     'x', 'y', 'x1', 'y1', 'x2', 'y2', 'rx', 'ry',
                     'id', 'viewBox', 'refX', 'refY', 'markerUnits',
                     'markerWidth', 'markerHeight', 'orient',
                     'transform'];
    shortcuts.forEach(s => { o[s] = o.a.bind(o, s) });
    return o;
  }

  function box(names) {
    let marginTop = 0;
    let marginBottom = 10;
    let marginLeft = 7;
    let marginRight = 10
    let fontSize = 15;
    let lineHeight = 18;
    let charWidth = 9;

    let longest = names.map(p => p.length).reduce((a,b) => Math.max(a,b), 0);
    let width = marginLeft + longest * charWidth + marginRight;
    let height = marginTop + marginBottom + lineHeight * names.length;

    let propText = names.map((n, i) => t('text', n).x(marginLeft)
                                                   .y((i+1) * lineHeight)
                                                   .fill('#657b83'));

    let g = t('g',
              t('rect').width(width).height(height).stroke('#657b83').fill('#fdf6e3'),
              ...propText)
      .a('font-size', fontSize)
      .a('font-family', 'Monospace')
      .height(height)
      .width(width);

    return g;
  }

  function link(a, b, options) {
    let {vertical, dashed, reversed, offset} = options || {};
    offset = offset || 15;

    let arrowLength = 50;
    let arrowTip = 15;
    let space = arrowLength + arrowTip;

    if (vertical) {
      var g = above(a, b, space);
      [a, b] = g.children;
      var y1 = a.attrs.height;
      var y2 = y1 + arrowLength;
      var x1 = offset, x2 = offset;
      var center = {x: x1, y: y1 + space / 2};
    } else {
      var g = beside(a, b, space);
      [a, b] = g.children;
      var x1 = a.attrs.width;
      var x2 = x1 + arrowLength;
      var y1 = offset, y2 = offset;
      var center = {x: x1 + space / 2, y: y1};
    }

    let arrow = t('line').x1(x1).x2(x2).y1(y1).y2(y2).stroke('#fdf6e3')
      .a('stroke-width', 5).a('marker-end', 'url(#triangle)');

    if (dashed) arrow.a('stroke-dasharray', '3 1');
    if (reversed) arrow.transform(`rotate(180 ${center.x} ${center.y})`);

    return t('g', a, arrow, b).width(g.attrs.width).height(g.attrs.height);
  }

  function beside(a, b, hspace) {
    hspace = hspace || 20;

    return t('g', a, b.transform(`translate(${a.attrs.width + hspace}, 0)`))
      .width(a.attrs.width + hspace + b.attrs.width)
      .height(Math.max(a.attrs.height, b.attrs.height));
  }

  function above(a, b, vspace) {
    vspace = vspace || 20;
    return t('g', a, b.transform(`translate(0, ${a.attrs.height + vspace})`))
      .width(Math.max(a.attrs.width, b.attrs.width))
      .height(a.attrs.height + vspace + b.attrs.height);
  }

  function name(n) {
    let g = box([n]);
    g.children[0].rx(10).ry(10);
    return g;
  }

  function ref(a, b, options) {
    options = options || {};
    options.dashed = true;
    return link(a, b, options);
  }

  let proto = link;
  let obj = function(o) { return box(Object.getOwnPropertyNames(o)) };

  function svg(...gs) {
    let triangle = t('marker', t('path').a('d', 'M 0 0 L 10 5 L 0 10 z'))
      .id('triangle').viewBox('0 0 10 10').refX(0).refY(5)
      .markerWidth(4).markerHeight(3)
      .orient('auto').fill('#fdf6e3');

    print(toSVG(t('svg', triangle, ...gs)));
  }
#+END_SRC

A simple way to build interpreters incrementally, as proposed to the
LASSY’15 workshop at Modularity 15.

* The code
An arithmetic expression language, the example taken by Wadler and
Odersky as a base to propose solutions to the expression problem.

** The base datatype
#+NAME: num
#+BEGIN_SRC js
  var num = {
    new: function(n) { return {__proto__: this, n} },
    eval: function() { return this.n }};
#+END_SRC

#+BEGIN_SRC js
  <<num>>

  var e1 = num.new(3);
  print(e1.eval());
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC js :results silent
  <<num>>

  <<svg>>
  redirect('img/num.svg')
  svg(ref(name('e1'),
          proto(obj(num.new(3)),
                ref(obj(num), name('num'),
                    {reversed:true}))))
#+END_SRC

[[file:img/num.svg]]

** Adding a data variant
#+NAME: plus
#+BEGIN_SRC js
  var plus = {
    new: function(l, r) { return {__proto__: this, l, r,} },
    eval: function() { return this.l.eval() + this.r.eval() }};
#+END_SRC

#+BEGIN_SRC js
  <<num>>
  <<plus>>

  var e2 = plus.new(num.new(1), num.new(2));
  print(e2.eval());
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>

  <<svg>>
  redirect('img/num-plus.svg')
  var $e1 = ref(name('e1'),
                proto(obj(num.new(3)),
                      ref(obj(num), name('num'),
                          {reversed:true})))

  var $e2 = ref(name('e2'),
                proto(obj(plus.new(num.new(1), num.new(2))),
                      ref(obj(plus), name('plus'),
                          {reversed:true})))

  svg(above($e1, $e2))
#+END_SRC

[[file:img/num-plus.svg]]

** Adding an operation
#+NAME: show-invasive
#+BEGIN_SRC js
  num.show = function() { return this.n.toString() }
  plus.show = function() { return this.l.show() + '+' + this.r.show() }
#+END_SRC

#+BEGIN_SRC js
  <<num>>
  <<plus>>

  var e2 = plus.new(num.new(1), num.new(2));

  <<show-invasive>>

  print(e2.show()); // Dynamic extension, without recreating the expression
  print(plus.new(num.new(1), num.new(2)).show());
#+END_SRC

#+RESULTS:
: 1+2
: 1+2

This extension is invasive: it modifies the prototypes of =num= and
=plus=.  If we want, we can extend safely both objects.

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show-invasive>>

  <<svg>>
  redirect('img/show-invasive.svg')
  var $e1 = ref(name('e1'),
                proto(obj(num.new(3)),
                      ref(obj(num), name('num'),
                          {reversed:true})))

  var $e2 = ref(name('e2'),
                proto(obj(plus.new(num.new(1), num.new(2))),
                      ref(obj(plus), name('plus'),
                          {reversed:true})))

  svg(above($e1, $e2))

#+END_SRC

[[file:img/show-invasive.svg]]

** Adding an operation as a module
#+NAME: show
#+BEGIN_SRC js
  var show = function(base) {
    var num = {__proto__: base.num,
      show() { return this.n.toString() }};

    var plus = {__proto__: base.plus,
      show() { return this.l.show() + '+' + this.r.show() }};

    return {num, plus};
  };
#+END_SRC

#+NAME: show-ex1
#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>

  var s = show({num, plus});
  print(s.plus.new(s.num.new(1), s.num.new(2)).show());
#+END_SRC

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show>>

  let s = show({num, plus});
  let e3 = s.plus.new(s.num.new(1), s.num.new(2));

  <<svg>>
  redirect('img/show-module.svg')
  let $s = ref(name('s'), obj(s));
  let $e2 = ref(name('e2'), proto(obj(plus.new(num.new(1), num.new(2))),
                                  ref(obj(plus), name('plus'), {reversed:true})));

  let $e3 =  ref(name('e3'),
                 proto(obj(e3),
                       ref(obj(e3.__proto__),
                           name('s.plus'), {reversed:true})));

  let g = link($e2, $e3, {vertical:true, reversed:true, offset: 220});
  svg(above($s, g))
#+END_SRC

[[file:img/show-module.svg]]

Works, but can mix languages in unsafe ways:

#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>

  var s = show({num, plus});

  try { print(s.plus.new(num.new(1), s.num.new(2)).show()); }
  catch (e) { print(e) }
#+END_SRC

#+RESULTS:
: TypeError: this.l.show is not a function

*** A use-case for =with=
#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>

  with(show({num, plus})) {
    print(plus.new(num.new(1), num.new(2)).show())
  }
#+END_SRC

#+RESULTS:
: 1+2

Cannot mix languages anymore because of name shadowing: only one =num=
and one =plus= is known in the body of =with=, and they are both from
the same language.

Inside =with=, here is what we see:

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show>>

  let s = show({num, plus});

  <<svg>>
  redirect('img/show-module-with.svg')
  let $num = ref(name('num'), proto(obj(s.num), obj(s.num.__proto__)));
  let $plus = ref(name('plus'), proto(obj(s.plus), obj(s.num.__proto__)));

  svg(above($num, $plus))
#+END_SRC

[[file:img/show-module-with.svg]]

Outside =with=, the =show= module is out of scope:

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show>>

  <<svg>>
  redirect('img/show-module-with-outside.svg')
  let $num = ref(name('num'), obj(num));
  let $plus = ref(name('plus'), obj(plus));

  svg(above($num, $plus))
#+END_SRC

[[file:img/show-module-with-outside.svg]]

*** Selective imports with an IIFE
#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>

  (function({num}) {
    print(num.new(1).show())
  }(show({num, plus})))
#+END_SRC

#+RESULTS:
: 1

Of course, here =plus= is in context, but we would actually put it in
a =base= module as well.

The two forms have a subtle difference: in a =with= we can modify the
values of the scope object by assigning to them, but in the IIFE,
assigning to the arguments has no effect outside the function.  In our
two examples, we always pass a fresh module so there is no issue.

** Modifying an operation
#+BEGIN_SRC js
<<num>>
<<plus>>

num.eval = function() { return this.n * 2 }

print(num.new(1).eval())
print(plus.new(num.new(1), num.new(2)).eval())
#+END_SRC

#+RESULTS:
: 2
: 6

Previous version of =num.eval= is lost: we have no reference to it
anymore.

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>

  <<svg>>
  redirect('img/modify-num.svg')
  var $e1 = ref(name('e1'),
                proto(obj(num.new(1)),
                      ref(box(['new', 'eval: this.n * 2']), name('num'),
                          {reversed:true})))

  var $prev = box(['new', 'eval: this.n'])

  svg(above($e1, $prev))
#+END_SRC

[[file:img/modify-num.svg]]

*** Non-destructive modification
#+NAME: double
#+BEGIN_SRC js
<<num>>
<<plus>>

var double = function(num_orig) {
  var num = {__proto__: num_orig,
    eval() { return num_orig.eval.call(this) * 2 }}
  return {num}
}
#+END_SRC

#+BEGIN_SRC js
<<double>>

with(double(num)) {
  with(double(num)) {
    print(plus.new(num.new(1), num.new(2)).eval())
  }
}
#+END_SRC

#+RESULTS:
: 12

Inside the inner-most =with=, the objects in scope are the modified
=num=, and the original =plus=.

#+BEGIN_SRC js :results silent
  <<svg>>
  redirect('img/modify-num-module.svg')
  var $num = ref(name('num'),
                proto(box(['eval: previous() * 2']),
                      proto(box(['eval: previous() * 2']),
                            box(['new', 'eval: this.n']))))

  var $plus = ref(name('plus'), obj(plus))

  svg(above($num, $plus))
#+END_SRC

[[file:img/modify-num-module.svg]]

While after the =with=, =num= refers to the original, unmodified object.

#+BEGIN_SRC js :results silent
  <<plus>>
  <<svg>>
  redirect('img/modify-num-module-outside.svg')
  var $num = ref(name('num'), box(['new', 'eval: this.n']))
  var $plus = ref(name('plus'), obj(plus))

  svg(above($num, $plus))
#+END_SRC

[[file:img/modify-num-module-outside.svg]]

** Passing state
Add a program counter incremented each time a data variant calls
=eval=.

#+NAME: state
#+BEGIN_SRC js
  var state = function(base, pc = 0) {
    var num = {__proto__: base.num,
               eval() { pc++; return base.num.eval.call(this) }}

    var plus = {__proto__: base.plus,
               eval() { pc++; return base.plus.eval.call(this) }}

    var getPC = () => pc

    return {num, plus, getPC}
  }
#+END_SRC

#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<state>>

  with (state({num, plus})) {
    print(getPC())
    print(plus.new(num.new(1), num.new(2)).eval())
    print(getPC())
  }
#+END_SRC

#+RESULTS:
: 0
: 3
: 3

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<state>>

  var s = state({num,plus});

  <<svg>>
  redirect('img/state.svg')
  var $getPC = ref(name('getPC'), box(['() => pc']))
  var $num = ref(name('num'), proto(obj(s.num), obj(s.num.__proto__)))
  var $plus = ref(name('plus'), proto(obj(s.plus), obj(s.plus.__proto__)))

  svg(above($getPC, above($num, $plus)))
#+END_SRC

[[file:img/state.svg]]

** All in one
Combine all the extensions without effort.

#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>
  <<state>>
  <<double>>

  with (state({num,plus})) {
    with (double(num)) {
      with (show({num,plus})) {
        print(getPC())
        let n = plus.new(num.new(1), num.new(2))
        print(n.eval())
        print(getPC())
        print(n.show())
      }}}
#+END_SRC

#+RESULTS:
: 0
: 6
: 3
: 1+2

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show>>
  <<state>>
  <<double>>

  with (state({num,plus})) {
    with (double(num)) {
      with (show({num,plus})) {
        var pc = getPC
        var n = plus.new(num.new(1), num.new(2))
      }}}

    <<svg>>
    redirect('img/all-in-one.svg')

  var $getPC = ref(name('getPC'), box(['() => pc']))
  var $nl = ref(name('n.l'),
                proto(obj(n.l),
                      proto(obj(n.l.__proto__),
                            proto(box(['eval', '(from double)']),
                                  proto(box(['eval', '(from state)']),
                                        ref(obj(n.l.__proto__.__proto__.__proto__.__proto__), name('num'),
                                            {reversed:true}))))))
  var $n = ref(name('n'),
               proto(obj(n),
                     proto(obj(n.__proto__),
                           proto(box(['eval', '(from state)']),
                                 ref(obj(n.l.__proto__.__proto__.__proto__), name('plus'),
                                     {reversed:true})))))

  svg(above($getPC, above($n, $nl)))
#+END_SRC

[[file:img/all-in-one.svg]]

* Discussion
** EcmaScript 6 Modules
We can use the module system of future versions of JS when scaling
this scheme to multiple files.

However, as of this writing, the module syntax does not seem to
support parameterized modules, preventing the composition done in the
=show=, =double= and =state= examples.

As a workaround, we can import a /function/ and dynamically
instantiate the module in the client files.

#+BEGIN_SRC js
import { _num } from "base"
import { _plus } from "plus"
import { show } from "show"
let { num, plus } = show({num: _num, plus: _plus})
#+END_SRC

This requires some boilerplate code to handle the temporary bindings
of =num= and =plus=.

** TODO Compatibility with other ways of constructing objects
Num.prototype.eval, at least.

** TODO Extending objects safely
How does that apply to built-in objects?  I tried to extend String,
but I suspect that methods returning =this= are trouble.

** TODO Applicability to a pattern-matching decomposition
As presented in the second part of Odersky and Zenger.  Is this
scheme strongly dependent of the decomposition chosen?

** Extensibility versus security
Core insight: adding indirection via names.  Lexically-closing over a
name is less flexible than referring to this name via `this`.  Since
`this` is dynamic, `this.n` can mean anything.  Give the possibility
to anyone to modify `this`, and anyone can change the meaning of the
code.  This turns JavaScript flaws into situational tools.  The same
insight is at work in dynamic dispatch or the factory pattern: bind
names late.

But critics are well-founded.  Binding late means you cannot know with
certainty what the code does; all the meanings may change at runtime.
This is the price of flexibility: each time a name may change meaning
at some point, you lose referential transparency, since you cannot
substitute the name for its definition -- it has more than one.  The
less you specify, the less coupling you have, the less you can
guarantee about the program.  Security (knowing with certainty what a
piece of code will do) is thus in opposition with extensibility
(leaving room for extending or modifying the piece of code in any way
possible).

Examples of this spectrum: lexically binding attributes and methods of
an object (non-revealing module pattern) vs. adding attributes and
methods as properties.  Adding methods via prototypes add indirection.
More indirection = more flexibility, but also less readability,
because the structure is now more complex.  Same goes for the
=__proto__: this= trick of my object pattern.

*** Lexical closures couple bindings at definition time (static)
Consider the following definition of a constructor for binary trees.

#+BEGIN_SRC js
let node = (value, left, right) => ({value, left, right})
let leaf = undefined
let pp = ({value, left, right}) =>
  `(${[value, (left ? pp(left) : ''), (right ? pp(right) : '')].join(' ').trim()})`

let btree = d => d >= 0 ? node(d, btree(d-1), btree(d-1)) : leaf

print(pp(btree(3)))
#+END_SRC

#+RESULTS:
: (3 (2 (1 (0) (0)) (1 (0) (0))) (2 (1 (0) (0)) (1 (0) (0))))

=btree= is conceptually independent of the implementation of =node=
and =leaf=, but since it closes over these implementation lexically,
=btree= is coupled to =node= and =leaf=.

The alternative is to untie the bindings of =node= and =leaf= by
adding them as parameters to =btree=.

#+BEGIN_SRC js
let btree = node => leaf => function btree1(d) {
  return d >= 0 ? node(d, btree1(d-1), btree1(d-1)) : leaf }

let node = (value, left, right) => ({value, left, right})
let leaf = undefined
let pp = ({value, left, right}) =>
  `(${[value, (left ? pp(left) : ''), (right ? pp(right) : '')].join(' ').trim()})`

print(pp(btree(node)(leaf)(3)))
#+END_SRC

#+RESULTS:
: (3 (2 (1 (0) (0)) (1 (0) (0))) (2 (1 (0) (0)) (1 (0) (0))))

Now we can actually use =btree= with any definition of =node= and
=leaf=.  Note that the function returned by =btree(node)(leaf)= is
identical to the =btree= of the previous example.  But in this
example, we can delay the creation of the closure.  Still, once the
closure =btree(node)(leaf)= is created, there is no way to change the
bindings of =node= and =leaf= in further calls.  It’s not as flexible
as dynamic scoping, but it’s also less surprising and more amenable to
optimization.  A good compromise on the flexibility/security spectrum.

** TODO Static typing
I suspect that (simple) static typing is incompatible with
intercession.  Just add types to the JS examples and see what problems
arise?

** A combination of simple features
The pattern presented make use of only simple features of the
language: objects as dictionaries, manipulation of scope using
function expressions ...

Pretty sure that I could build a simple object language that would
allow the expression of such constructs without the gotchas of
JavaScript.

** Scoping issues
All my examples work fine when the AST is /lexically/ constructed in
the body of a =with= or an IIFE.  It does not work anymore when the
AST is constructed dynamically inside a =with=.

#+BEGIN_SRC js
function f() {
  a();
}

with (module(a, b)) {
  f()
}
#+END_SRC

The =f= function has free variables.  I think that context-oriented
programming allows this call to work, but is that a good thing?

Another instance of the extensibility/security spectrum: do you allow
free names to bind dynamically?

Here, one solution would be to bind the names as arguments to =f=.

** It’s all a matter of names and scopes
What names are in scope, either statically or dynamically, and what
they refer to.  This is the crux of the issue.

If names always refer to the same objects, statically or dynamically,
then you have complete referential transparency, and full security.
The program is easier to understand since names are not ambiguous.

If names refer to some objects statically, then to others dynamically,
then you have flexibility, at the price of a more complex system.
Security is harder to guarantee.

# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
** An objection by Pierce and Harper
Good points are made about modules in [[http://www.cis.upenn.edu/~bcpierce/papers/modules-icfp.ps][Advanced Module Systems]].  They
conclude that /generic references/ are needed for flexibility (making
a reference to /a/ module that respects the interface A, rather than
/the/ module A), but that parameterization on modules (one way to
achieve generic references) does not scale.

What we exhibit in this document is parameterization on modules.  It
is true that we are subject to scaling issues.  All modules depending
on =show= must supply the appropriate =num= and =plus=.  Adding a
dependency to =show= will cascade through all users of =show=.

One mitigation would be to also provide default modules: if =show=
requires modules =num= and =plus=, then when importing =show= without
specifying modules will implicitly take the =num= and =plus= modules
in the current scope.

* Extension
** Adding another variant after =show=
If =show= is defined only for =num= and =plus=, but we define =minus=
later, how do we add the =show= operation to =minus=?

#+NAME: minus
#+BEGIN_SRC js
  var minus = {
    new(n) { return {__proto__: this, n} }
    ,eval() { return -this.n } }
#+END_SRC

#+NAME: show-minus
#+BEGIN_SRC js
  var show_minus = minus_orig => {
    var minus = {__proto__: minus_orig
                 ,show() { return (-this.n).toString() }}
    return {minus}
  }
#+END_SRC

#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>
  <<minus>>
  <<show-minus>>

  with (show({num, plus})) {
    with (show_minus(minus)) {
      print(plus.new(num.new(1), num.new(2)).show())
      print(plus.new(num.new(2), minus.new(1)).show()) }}
#+END_SRC

#+RESULTS:
: 1+2
: 2+-1

*** Same goes for double/show

#+NAME: double-show
#+BEGIN_SRC js
var double_show = (num_orig) => {
  var num = {__proto__: num_orig,
    show() { return (this.n * 2).toString() }}
  return {num} }
#+END_SRC

#+BEGIN_SRC js
<<num>>
<<plus>>
<<double>>
<<show>>
<<double-show>>

with(double(num)) {
  with(double(num)) {
    with(show({num,plus})) {
      with(double_show(num)) {
        print(plus.new(num.new(1), num.new(2)).show()) }}}}
#+END_SRC

#+RESULTS:
: 2+4
