#+PROPERTY: header-args :results output :noweb yes
# C-c C-v C-b org-babel-execute-buffer
# C-c C-x C-M-v org-redisplay-inline-images

#+NAME: svg
#+BEGIN_SRC js
  function toMarkup(obj, open, close, attr) {
    if (typeof obj !== 'object') return obj.toString();

    let tagName = obj.t;
    let attrs = Object.getOwnPropertyNames(obj.attrs).map(n => attr(n, obj.attrs[n]));
    let content = obj.children.map(o => toMarkup(o, open, close, attr)).join('');
    return open(tagName, attrs) + content + close(tagName);
  }

  function toSVG(obj) {
    function openSVG(tagName, attrs) { return '<' + (tagName + ' ' + attrs.join(' ')).trim() + '>' }
    function closeSVG(tagName) { return '</' + tagName + '>' }
    function attrSVG(k, v) { return k  + '="' + v + '"' }
    return toMarkup(obj, openSVG, closeSVG, attrSVG);
  }

  function t(tagName, ...args) {
    let o = {
      t: tagName,
      attrs: Object.create(null),
      a(k, v) { o.attrs[k] = v; return o },
      children: args,
    };
    let shortcuts = ['width', 'height', 'fill', 'stroke', 'cx', 'cy', 'r',
                     'x', 'y', 'x1', 'y1', 'x2', 'y2', 'rx', 'ry',
                     'id', 'viewBox', 'refX', 'refY', 'markerUnits',
                     'markerWidth', 'markerHeight', 'orient',
                     'transform'];
    shortcuts.forEach(s => { o[s] = o.a.bind(o, s) });
    return o;
  }

  function box(names) {
    let marginTop = 0;
    let marginBottom = 10;
    let marginLeft = 7;
    let marginRight = 10
    let fontSize = 15;
    let lineHeight = 18;
    let charWidth = 9;

    let longest = names.map(p => p.length).reduce((a,b) => Math.max(a,b), 0);
    let width = marginLeft + longest * charWidth + marginRight;
    let height = marginTop + marginBottom + lineHeight * names.length;

    let propText = names.map((n, i) => t('text', n).x(marginLeft)
                                                   .y((i+1) * lineHeight)
                                                   .fill('#657b83'));

    let g = t('g',
              t('rect').width(width).height(height).stroke('#657b83').fill('#fdf6e3'),
              ...propText)
      .a('font-size', fontSize)
      .a('font-family', 'Monospace')
      .height(height)
      .width(width);

    return g;
  }

  function link(a, b, options) {
    let {vertical, dashed, reversed, offset} = options || {};
    offset = offset || 15;

    let arrowLength = 50;
    let arrowTip = 15;
    let space = arrowLength + arrowTip;

    if (vertical) {
      var g = above(a, b, space);
      [a, b] = g.children;
      var y1 = a.attrs.height;
      var y2 = y1 + arrowLength;
      var x1 = offset, x2 = offset;
      var center = {x: x1, y: y1 + space / 2};
    } else {
      var g = beside(a, b, space);
      [a, b] = g.children;
      var x1 = a.attrs.width;
      var x2 = x1 + arrowLength;
      var y1 = offset, y2 = offset;
      var center = {x: x1 + space / 2, y: y1};
    }

    let arrow = t('line').x1(x1).x2(x2).y1(y1).y2(y2).stroke('#fdf6e3')
      .a('stroke-width', 5).a('marker-end', 'url(#triangle)');

    if (dashed) arrow.a('stroke-dasharray', '3 1');
    if (reversed) arrow.transform(`rotate(180 ${center.x} ${center.y})`);

    return t('g', a, arrow, b).width(g.attrs.width).height(g.attrs.height);
  }

  function beside(a, b, hspace) {
    hspace = hspace || 20;

    return t('g', a, b.transform(`translate(${a.attrs.width + hspace}, 0)`))
      .width(a.attrs.width + hspace + b.attrs.width)
      .height(Math.max(a.attrs.height, b.attrs.height));
  }

  function above(a, b, vspace) {
    vspace = vspace || 20;
    return t('g', a, b.transform(`translate(0, ${a.attrs.height + vspace})`))
      .width(Math.max(a.attrs.width, b.attrs.width))
      .height(a.attrs.height + vspace + b.attrs.height);
  }

  function name(n) {
    let g = box([n]);
    g.children[0].rx(10).ry(10);
    return g;
  }

  function ref(a, b, options) {
    options = options || {};
    options.dashed = true;
    return link(a, b, options);
  }

  let proto = link;
  let obj = function(o) { return box(Object.getOwnPropertyNames(o)) };

  function svg(...gs) {
    let triangle = t('marker', t('path').a('d', 'M 0 0 L 10 5 L 0 10 z'))
      .id('triangle').viewBox('0 0 10 10').refX(0).refY(5)
      .markerWidth(4).markerHeight(3)
      .orient('auto').fill('#fdf6e3');

    print(toSVG(t('svg', triangle, ...gs)));
  }
#+END_SRC

A simple way to build interpreters incrementally, as proposed to the
LASSY’15 workshop at Modularity 15.

* The code
An arithmetic expression language, the example taken by Wadler and
Odersky as a base to propose solutions to the expression problem.

** The base datatype
#+NAME: num
#+BEGIN_SRC js
  var num = {
    new: function(n) { return {__proto__: this, n} },
    eval: function() { return this.n }};
#+END_SRC

#+BEGIN_SRC js
  <<num>>

  var e1 = num.new(3);
  print(e1.eval());
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC js :results silent
  <<num>>

  <<svg>>
  redirect('img/num.svg')
  svg(ref(name('e1'),
          proto(obj(num.new(3)),
                ref(obj(num), name('num'),
                    {reversed:true}))))
#+END_SRC

[[file:img/num.svg]]

** Adding a data variant
#+NAME: plus
#+BEGIN_SRC js
  var plus = {
    new: function(l, r) { return {__proto__: this, l, r,} },
    eval: function() { return this.l.eval() + this.r.eval() }};
#+END_SRC

#+BEGIN_SRC js
  <<num>>
  <<plus>>

  var e2 = plus.new(num.new(1), num.new(2));
  print(e2.eval());
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>

  <<svg>>
  redirect('img/num-plus.svg')
  var $e1 = ref(name('e1'),
                proto(obj(num.new(3)),
                      ref(obj(num), name('num'),
                          {reversed:true})))

  var $e2 = ref(name('e2'),
                proto(obj(plus.new(num.new(1), num.new(2))),
                      ref(obj(plus), name('plus'),
                          {reversed:true})))

  svg(above($e1, $e2))
#+END_SRC

[[file:img/num-plus.svg]]

** Adding an operation
#+NAME: show-invasive
#+BEGIN_SRC js
  num.show = function() { return this.n.toString() }
  plus.show = function() { return this.l.show() + '+' + this.r.show() }
#+END_SRC

#+BEGIN_SRC js
  <<num>>
  <<plus>>

  var e2 = plus.new(num.new(1), num.new(2));

  <<show-invasive>>

  print(e2.show()); // Dynamic extension, without recreating the expression
  print(plus.new(num.new(1), num.new(2)).show());
#+END_SRC

#+RESULTS:
: 1+2
: 1+2

This extension is invasive: it modifies the prototypes of =num= and
=plus=.  If we want, we can extend safely both objects.

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show-invasive>>

  <<svg>>
  redirect('img/show-invasive.svg')
  var $e1 = ref(name('e1'),
                proto(obj(num.new(3)),
                      ref(obj(num), name('num'),
                          {reversed:true})))

  var $e2 = ref(name('e2'),
                proto(obj(plus.new(num.new(1), num.new(2))),
                      ref(obj(plus), name('plus'),
                          {reversed:true})))

  svg(above($e1, $e2))

#+END_SRC

[[file:img/show-invasive.svg]]

** Adding an operation as a module
#+NAME: show
#+BEGIN_SRC js
  var show = function(base) {
    var num = {__proto__: base.num,
      show() { return this.n.toString() }};

    var plus = {__proto__: base.plus,
      show() { return this.l.show() + '+' + this.r.show() }};

    return {num, plus};
  };
#+END_SRC

#+NAME: show-ex1
#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>

  var s = show({num, plus});
  print(s.plus.new(s.num.new(1), s.num.new(2)).show());
#+END_SRC

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show>>

  let s = show({num, plus});
  let e3 = s.plus.new(s.num.new(1), s.num.new(2));

  <<svg>>
  redirect('img/show-module.svg')
  let $s = ref(name('s'), obj(s));
  let $e2 = ref(name('e2'), proto(obj(plus.new(num.new(1), num.new(2))),
                                  ref(obj(plus), name('plus'), {reversed:true})));

  let $e3 =  ref(name('e3'),
                 proto(obj(e3),
                       ref(obj(e3.__proto__),
                           name('s.plus'), {reversed:true})));

  let g = link($e2, $e3, {vertical:true, reversed:true, offset: 220});
  svg(above($s, g))
#+END_SRC

[[file:img/show-module.svg]]

Works, but can mix languages in unsafe ways:

#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>

  var s = show({num, plus});

  try { print(s.plus.new(num.new(1), s.num.new(2)).show()); }
  catch (e) { print(e) }
#+END_SRC

#+RESULTS:
: TypeError: this.l.show is not a function

*** A use-case for =with=
#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>

  with(show({num, plus})) {
    print(plus.new(num.new(1), num.new(2)).show())
  }
#+END_SRC

#+RESULTS:
: 1+2

Cannot mix languages anymore because of name shadowing: only one =num=
and one =plus= is known in the body of =with=, and they are both from
the same language.

Inside =with=, here is what we see:

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show>>

  let s = show({num, plus});

  <<svg>>
  redirect('img/show-module-with.svg')
  let $num = ref(name('num'), proto(obj(s.num), obj(s.num.__proto__)));
  let $plus = ref(name('plus'), proto(obj(s.plus), obj(s.num.__proto__)));

  svg(above($num, $plus))
#+END_SRC

[[file:img/show-module-with.svg]]

Outside =with=, the =show= module is out of scope:

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show>>

  <<svg>>
  redirect('img/show-module-with-outside.svg')
  let $num = ref(name('num'), obj(num));
  let $plus = ref(name('plus'), obj(plus));

  svg(above($num, $plus))
#+END_SRC

[[file:img/show-module-with-outside.svg]]

*** Selective imports with an IIFE
#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>

  (function({num}) {
    print(num.new(1).show())
  }(show({num, plus})))
#+END_SRC

#+RESULTS:
: 1

Of course, here =plus= is in context, but we would actually put it in
a =base= module as well.

The two forms have a subtle difference: in a =with= we can modify the
values of the scope object by assigning to them, but in the IIFE,
assigning to the arguments has no effect outside the function.  In our
two examples, we always pass a fresh module so there is no issue.

** Modifying an operation
#+BEGIN_SRC js
<<num>>
<<plus>>

num.eval = function() { return this.n * 2 }

print(num.new(1).eval())
print(plus.new(num.new(1), num.new(2)).eval())
#+END_SRC

#+RESULTS:
: 2
: 6

Previous version of =num.eval= is lost: we have no reference to it
anymore.

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>

  <<svg>>
  redirect('img/modify-num.svg')
  var $e1 = ref(name('e1'),
                proto(obj(num.new(1)),
                      ref(box(['new', 'eval: this.n * 2']), name('num'),
                          {reversed:true})))

  var $prev = box(['new', 'eval: this.n'])

  svg(above($e1, $prev))
#+END_SRC

[[file:img/modify-num.svg]]

*** Non-destructive modification
#+NAME: double
#+BEGIN_SRC js
<<num>>
<<plus>>

var double = function(num_orig) {
  var num = {__proto__: num_orig,
    eval() { return num_orig.eval.call(this) * 2 }}
  return {num}
}
#+END_SRC

#+BEGIN_SRC js
<<double>>

with(double(num)) {
  with(double(num)) {
    print(plus.new(num.new(1), num.new(2)).eval())
  }
}
#+END_SRC

#+RESULTS:
: 12

Inside the inner-most =with=, the objects in scope are the modified
=num=, and the original =plus=.

#+BEGIN_SRC js :results silent
  <<svg>>
  redirect('img/modify-num-module.svg')
  var $num = ref(name('num'),
                proto(box(['eval: previous() * 2']),
                      proto(box(['eval: previous() * 2']),
                            box(['new', 'eval: this.n']))))

  var $plus = ref(name('plus'), obj(plus))

  svg(above($num, $plus))
#+END_SRC

[[file:img/modify-num-module.svg]]

While after the =with=, =num= refers to the original, unmodified object.

#+BEGIN_SRC js :results silent
  <<plus>>
  <<svg>>
  redirect('img/modify-num-module-outside.svg')
  var $num = ref(name('num'), box(['new', 'eval: this.n']))
  var $plus = ref(name('plus'), obj(plus))

  svg(above($num, $plus))
#+END_SRC

[[file:img/modify-num-module-outside.svg]]

** Passing state
Add a program counter incremented each time a data variant calls
=eval=.

#+NAME: state
#+BEGIN_SRC js
  var state = function(base, pc = 0) {
    var num = {__proto__: base.num,
               eval() { pc++; return base.num.eval.call(this) }}

    var plus = {__proto__: base.plus,
               eval() { pc++; return base.plus.eval.call(this) }}

    var getPC = () => pc

    return {num, plus, getPC}
  }
#+END_SRC

#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<state>>

  with (state({num, plus})) {
    print(getPC())
    print(plus.new(num.new(1), num.new(2)).eval())
    print(getPC())
  }
#+END_SRC

#+RESULTS:
: 0
: 3
: 3

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<state>>

  var s = state({num,plus});

  <<svg>>
  redirect('img/state.svg')
  var $getPC = ref(name('getPC'), box(['() => pc']))
  var $num = ref(name('num'), proto(obj(s.num), obj(s.num.__proto__)))
  var $plus = ref(name('plus'), proto(obj(s.plus), obj(s.plus.__proto__)))

  svg(above($getPC, above($num, $plus)))
#+END_SRC

[[file:img/state.svg]]

** All in one
Combine all the extensions without effort.

#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>
  <<state>>
  <<double>>

  with (state({num,plus})) {
    with (double(num)) {
      with (show({num,plus})) {
        print(getPC())
        let n = plus.new(num.new(1), num.new(2))
        print(n.eval())
        print(getPC())
        print(n.show())
      }}}
#+END_SRC

#+RESULTS:
: 0
: 6
: 3
: 1+2

#+BEGIN_SRC js :results silent
  <<num>>
  <<plus>>
  <<show>>
  <<state>>
  <<double>>

  with (state({num,plus})) {
    with (double(num)) {
      with (show({num,plus})) {
        var pc = getPC
        var n = plus.new(num.new(1), num.new(2))
      }}}

    <<svg>>
    redirect('img/all-in-one.svg')

  var $getPC = ref(name('getPC'), box(['() => pc']))
  var $nl = ref(name('n.l'),
                proto(obj(n.l),
                      proto(obj(n.l.__proto__),
                            proto(box(['eval', '(from double)']),
                                  proto(box(['eval', '(from state)']),
                                        ref(obj(n.l.__proto__.__proto__.__proto__.__proto__), name('num'),
                                            {reversed:true}))))))
  var $n = ref(name('n'),
               proto(obj(n),
                     proto(obj(n.__proto__),
                           proto(box(['eval', '(from state)']),
                                 ref(obj(n.l.__proto__.__proto__.__proto__), name('plus'),
                                     {reversed:true})))))

  svg(above($getPC, above($n, $nl)))
#+END_SRC

[[file:img/all-in-one.svg]]

* Discussion
** EcmaScript 6 Modules
We can use the module system of future versions of JS when scaling
this scheme to multiple files.

However, as of this writing, the module syntax does not seem to
support parameterized modules, preventing the composition done in the
=show=, =double= and =state= examples.

As a workaround, we can import a /function/ and dynamically
instantiate the module in the client files.

#+BEGIN_SRC js
import { _num } from "base"
import { _plus } from "plus"
import { show } from "show"
let { num, plus } = show({num: _num, plus: _plus})
#+END_SRC

This requires some boilerplate code to handle the temporary bindings
of =num= and =plus=.

** TODO Compatibility with other ways of constructing objects
Num.prototype.eval, at least.

** TODO Extending objects safely
How does that apply to built-in objects?  I tried to extend String,
but I suspect that methods returning =this= are trouble.

** TODO Applicability to a pattern-matching decomposition
As presented in the second part of Odersky and Zenger.  Is this
scheme strongly dependent of the decomposition chosen?

** Extensibility versus security
Core insight: adding indirection via names.  Lexically-closing over a
name is less flexible than referring to this name via `this`.  Since
`this` is dynamic, `this.n` can mean anything.  Give the possibility
to anyone to modify `this`, and anyone can change the meaning of the
code.  This turns JavaScript flaws into situational tools.  The same
insight is at work in dynamic dispatch or the factory pattern: bind
names late.

But critics are well-founded.  Binding late means you cannot know with
certainty what the code does; all the meanings may change at runtime.
This is the price of flexibility: each time a name may change meaning
at some point, you lose referential transparency, since you cannot
substitute the name for its definition -- it has more than one.  The
less you specify, the less coupling you have, the less you can
guarantee about the program.  Security (knowing with certainty what a
piece of code will do) is thus in opposition with extensibility
(leaving room for extending or modifying the piece of code in any way
possible).

Examples of this spectrum: lexically binding attributes and methods of
an object (non-revealing module pattern) vs. adding attributes and
methods as properties.  Adding methods via prototypes add indirection.
More indirection = more flexibility, but also less readability,
because the structure is now more complex.  Same goes for the
=__proto__: this= trick of my object pattern.

*** Lexical closures couple bindings at definition time (static)
Consider the following definition of a constructor for binary trees.

#+BEGIN_SRC js
let node = (value, left, right) => ({value, left, right})
let leaf = undefined
let pp = ({value, left, right}) =>
  `(${[value, (left ? pp(left) : ''), (right ? pp(right) : '')].join(' ').trim()})`

let btree = d => d >= 0 ? node(d, btree(d-1), btree(d-1)) : leaf

print(pp(btree(3)))
#+END_SRC

#+RESULTS:
: (3 (2 (1 (0) (0)) (1 (0) (0))) (2 (1 (0) (0)) (1 (0) (0))))

=btree= is conceptually independent of the implementation of =node=
and =leaf=, but since it closes over these implementation lexically,
=btree= is coupled to =node= and =leaf=.

The alternative is to untie the bindings of =node= and =leaf= by
adding them as parameters to =btree=.

#+BEGIN_SRC js
let btree = node => leaf => function btree1(d) {
  return d >= 0 ? node(d, btree1(d-1), btree1(d-1)) : leaf }

let node = (value, left, right) => ({value, left, right})
let leaf = undefined
let pp = ({value, left, right}) =>
  `(${[value, (left ? pp(left) : ''), (right ? pp(right) : '')].join(' ').trim()})`

print(pp(btree(node)(leaf)(3)))
#+END_SRC

#+RESULTS:
: (3 (2 (1 (0) (0)) (1 (0) (0))) (2 (1 (0) (0)) (1 (0) (0))))

Now we can actually use =btree= with any definition of =node= and
=leaf=.  Note that the function returned by =btree(node)(leaf)= is
identical to the =btree= of the previous example.  But in this
example, we can delay the creation of the closure.  Still, once the
closure =btree(node)(leaf)= is created, there is no way to change the
bindings of =node= and =leaf= in further calls.  It’s not as flexible
as dynamic scoping, but it’s also less surprising and more amenable to
optimization.  A good compromise on the flexibility/security spectrum.

** TODO Static typing
I suspect that (simple) static typing is incompatible with
intercession.  Just add types to the JS examples and see what problems
arise?

** A combination of simple features
The pattern presented make use of only simple features of the
language: objects as dictionaries, manipulation of scope using
function expressions ...

Pretty sure that I could build a simple object language that would
allow the expression of such constructs without the gotchas of
JavaScript.

** Scoping issues
All my examples work fine when the AST is /lexically/ constructed in
the body of a =with= or an IIFE.  It does not work anymore when the
AST is constructed dynamically inside a =with=.

#+BEGIN_SRC js
function f() {
  a();
}

with (module(a, b)) {
  f()
}
#+END_SRC

The =f= function has free variables.  I think that context-oriented
programming allows this call to work, but is that a good thing?

Another instance of the extensibility/security spectrum: do you allow
free names to bind dynamically?

Here, one solution would be to bind the names as arguments to =f=.

** It’s all a matter of names and scopes
What names are in scope, either statically or dynamically, and what
they refer to.  This is the crux of the issue.

If names always refer to the same objects, statically or dynamically,
then you have complete referential transparency, and full security.
The program is easier to understand since names are not ambiguous.

If names refer to some objects statically, then to others dynamically,
then you have flexibility, at the price of a more complex system.
Security is harder to guarantee.

# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
** An objection by Pierce and Harper
Good points are made about modules in [[http://www.cis.upenn.edu/~bcpierce/papers/modules-icfp.ps][Advanced Module Systems]].  They
conclude that /generic references/ are needed for flexibility (making
a reference to /a/ module that respects the interface A, rather than
/the/ module A), but that parameterization on modules (one way to
achieve generic references) does not scale.

What we exhibit in this document is parameterization on modules.  It
is true that we are subject to scaling issues.  All modules depending
on =show= must supply the appropriate =num= and =plus=.  Adding a
dependency to =show= will cascade through all users of =show=.

One mitigation would be to also provide default modules: if =show=
requires modules =num= and =plus=, then when importing =show= without
specifying modules will implicitly take the =num= and =plus= modules
in the current scope.

** Reviews from FOAL’15 workshop
*** Review 1
This paper describes a pattern for implementing interpreters in
JavaScript, such that instrumentation can be performed on them in a
modular way, without having to change the interpreter code.

Overall, the paper is well written and is easy to read. It provides a
good introduction to the world of interpreter instrumentation.

Reading through this paper I got the feeling it should end with a
description of a refactored version of the Narcissus interpreter and a
modular implementation of faceted evaluation. Instead, the paper ended
with a discussion on what it should take to implement such
artifacts. I guess this is OK for a workshop paper, but I would
definitely encourage the authors to complete this.

One thing that bothered me with the pattern described by the authors
is in the central role the "with" keyword takes. The "with" keyword is
powerful, as it allows users to modify the lexical scoping of a
block. However, it is also deprecated. ES5 strict mode does not allow
the use of "with", and this means code that uses "with" in the real
world, lives on borrowed time. The main reason for that (according to
Brendan Eich) is security (quoting his tweet on the subject):

@angusTweets no, optimization is not the issue. with violates lexical
scope, making program analysis (e.g. for security) hard to infeasible.

Interestingly, security (and in particular, dynamic analysis) is the
motivation behind this paper, so I wonder how well an interpreter
designed using the pattern described in the paper would be successful
analyzing its own code (it is, after all, metacircular).

In Section 4, the authors claim that the dynamic typing in Javascript
allowed the authors do things that would otherwise be "difficuls or
even impossible to do". I tend to disagree. I've seen some heroic
compositions done in languages such as Scala and Haskell. Unlike the
original instrumentation, that modified the signature of methods, the
pattern described in this paper only decorates functions and objects
with additional functionality. When an extra parameter needs to flow
down (such as the PC), it is done through a closure. The eval()
method's signature was never changed. I would suggest that the authors
lower the tone of this paragraph, only claiming it was easier this
way.

Some point of personal taste maybe, but I did not like the use of
Mozilla-specific dialect in the code examples. They are unfamiliar to
most readers (as developers are discouraged from using them due to
compatibility issues), and may give the (wrong) impression that this
pattern can only work in this dialect of JS. Although less elegant, I
would suggest using standard EcmaScript for the code examples in the
paper.

*** Review 2
This paper describes the instrumentation problem, which is an
extension of the expression problem defined by Wadler.  They define
four requirements for modular instrumentation of interpreters to
implement dynamic analyses (modularity, intercession, local state, and
pluggability).  The then look at a case study in the Narcissus
interpreter by extending it support faceted evaluation.

The authors explicitly state they don’t believe their approach works
in a static typed language (like Java), due to the requirement of
intercession.  This seems reasonable to argue.  They also state at the
end they believe their approach would generalize to other JS
interpreters, which again seems reasonable.  My question is do the
authors think their approach generalizes to any other dynamically
typed languages (say, Python)?  What is the exact set of features a
language must contain in order for this approach to be applicable?
The authors heavily hint at such features in Sec. 4 - I’d like to see
it made more explicit.

I do not believe the authors are quite correct in assuming that an AOP
solution to the problem would suffer “performance penalties of dynamic
weaving.”  Previous works have shown that simple caching mechanisms
can avoid most overhead for dynamic weaving.

Minor typos:
- abstract: ‘of an an interpreter’
- 3.1.2 pg 3 - ‘to print expression*S* instead of evaluating’
- 4 pg 5 - last word - ‘we present here show*S*’

** Rebuttal
*** Should end with Narcissus instrumentation itself.
Agree.  This is planned, but it would be hard anyway to give all the
details in 6 pages.

**** Action
Future work.

*** =with= is deprecated.
Not quite.  Designers of ECMAScript have stated numerous times that
future versions of the language are backward-compatible.  All the
warts are here forever, including =with=.  It is true that =with= is
disallowed in strict mode, but browsers implementing the ECMAScript
standard should follow the /whole/ standard, not just strict mode.

Besides, the paper gives an interesting use-case for =with=, proving
that it’s not the useless and dangerous language feature that it’s
often seen as.

Anyway, an IIFE can serve the same purpose as =with=, with additional
control (as shown at the end \sect3.1.2).  The syntax is just noisier.

**** DONE Action
state that the usage of =with= is not necessary, merely easier to read
than IIFE.  And that it provides an interesting use-case for an often
disregarded feature.

*** =with= hampers analysis.
Confusion.  =with= does indeed make static analysis hard, but it does
not hamper dynamic analysis.

**** Action
None.

*** Claiming that instrumentation would be impossible to type.
Agree that it needs more justification.  Theoretically, it seems
possible to type.  It can however be “heroic” to do so, as the
reviewer points out.  Dynamic typing does not get in the way.

**** DONE Action
State that dynamic typing made it easier, as arbitrary intercession
can became hairy to express in statically-typed languages.

*** Mozilla-specific extensions are unfamiliar,
and may give the (wrong) impression that we are using a non-standard
JS.  Suggests using plain EcmaScript.

Confusion.  No Mozilla-specific extensions, just EcmaScript 6 that is
not implemented in every browser.  More readable, and you can get Ecma
5 back with tools if you want.

**** DONE Action
In intro to \sect3, state that it’s standard we use only syntactic sugar
constructs for their additional readability.

*** Does the approach generalize to other dynamic languages?
(e.g. Python).  List the exact features required.  Alluded in \sect4,
could be more explicit.

Heartily agree.

**** TODO Action
(Try to) list the exact language features, and based on that list
state in which other languages it would be possible, and in which it
might not be.

*** AOP penalties could be easily overcame
Don’t state what you don’t show?

Agree.  Although this was the discussion section, the arguments lacked
the facts for backing it up.

**** DONE Action
Focus on the use of simple features, do not assume that AOP would be
costly without benchmarks.

*** Typos
- abstract: ‘of an an interpreter’
- 3.1.2 pg 3 - ‘to print expression*S* instead of evaluating’
- 4 pg 5 - last word - ‘we present here show*S*’

**** DONE Action
Correct.

*** Can you do that with decorators?
Reviewer #1 claim: “this pattern only decorates functions and objects
with additional functionality”.

Can we do that with decorators?  ES7 has a [[https://github.com/wycats/javascript-decorators][decorator proposal]]: a
lightweight syntax addition that calls a function before setting a
property on an object.

#+BEGIN_SRC js
class Person {
  @readonly
  name() { return `${this.first} ${this.last}` }
}

function readonly(target, name, descriptor) {
  ...
}
#+END_SRC

This desugars to:

#+BEGIN_SRC js
function Person() {}

let descriptor = {
  value: name() { return `${this.first} ${this.last}` },
  enumerable: false,
  configurable: true,
  writable: true
}

descriptor = readonly(Person.prototype, 'name', descriptor) || descriptor
Object.defineProperty(Person.prototype, 'name', descriptor)
#+END_SRC

So, in essence a decorator is syntactic sugar for wrapping a method.

Let’s see if we can do that with =double=.

#+BEGIN_SRC js
var Num = function(n) { this.n = n }
Num.prototype.eval = function() { return this.n }

var e1 = new Num(3)
print(e1.eval())

// Decorator
var double = function(f) {
  return function() { return f.call(this) * 2 }}

Num.prototype.eval = double(function() { return this.n })
print(e1.eval())
#+END_SRC

#+RESULTS:
: 3
: 6

With syntactic sugar, you would write the following.

#+BEGIN_SRC js
let double = function(_, _, f) {
  return function() { return f.call(this) * 2 }}

class Num
  constructor(n) { this.n = n }

  @double
  eval() { return this.n }
#+END_SRC

So we can indeed view =double= as a decorator.  But this is only the
/destructive/ version of =double=.  It is easier to read as the
destruction is right next to the function definition.  However, the
destructive variants are not the crux of our pattern; modules are.

In the paper, we need to have both base variants and extensions
available at runtime; that’s why we present non-destructive
extensions.  The intent decorator is not to have two variants of a
method co-existing, so that’s not the right mechanism for our task.

If we wanted to have two variants with decorators, we would need to
write the base class /twice/.

#+BEGIN_SRC js
class Num
  constructor(n) { this.n = n }
  eval() { return this.n }

let double = function(_, _, f) {
  return function() { return f.call(this) * 2 }}

class Double
  constructor(n) { this.n = n }

  @double
  eval() { return this.n }
#+END_SRC

And now this seems extremely convoluted to use a decorator instead of
just defining =Double.eval= to return =n*2=.

Our goal is to avoid duplication when making small changes to a base
code, so this mechanism does not fit.

If we think about it, we present decorators on /modules/ rather than
on functions and objects.

#+BEGIN_SRC js
var double = function(base) {
  var num = {__proto__: base.num,
    eval() { return base.num.eval.call(this) * 2 }}

  return {num} }
#+END_SRC

This =double= function takes a base =num= module, and returns a new
one.  A decorator takes a function, and returns a new one with
additional functionality (it should not change the signature of the
function, or at least return a subtype of it).  But once again, we
don’t want to erase the previous module; we want to have both the base
and extension existing at runtime, so that we can switch between them.

* Extension
** Adding another variant after =show=
If =show= is defined only for =num= and =plus=, but we define =minus=
later, how do we add the =show= operation to =minus=?

#+NAME: minus
#+BEGIN_SRC js
  var minus = {
    new(n) { return {__proto__: this, n} }
    ,eval() { return -this.n } }
#+END_SRC

#+NAME: show-minus
#+BEGIN_SRC js
  var show_minus = minus_orig => {
    var minus = {__proto__: minus_orig
                 ,show() { return (-this.n).toString() }}
    return {minus}
  }
#+END_SRC

#+BEGIN_SRC js
  <<num>>
  <<plus>>
  <<show>>
  <<minus>>
  <<show-minus>>

  with (show({num, plus})) {
    with (show_minus(minus)) {
      print(plus.new(num.new(1), num.new(2)).show())
      print(plus.new(num.new(2), minus.new(1)).show()) }}
#+END_SRC

#+RESULTS:
: 1+2
: 2+-1

*** Same goes for double/show

#+NAME: double-show
#+BEGIN_SRC js
var double_show = (num_orig) => {
  var num = {__proto__: num_orig,
    show() { return (this.n * 2).toString() }}
  return {num} }
#+END_SRC

#+BEGIN_SRC js
<<num>>
<<plus>>
<<double>>
<<show>>
<<double-show>>

with(double(num)) {
  with(double(num)) {
    with(show({num,plus})) {
      with(double_show(num)) {
        print(plus.new(num.new(1), num.new(2)).show()) }}}}
#+END_SRC

#+RESULTS:
: 2+4
