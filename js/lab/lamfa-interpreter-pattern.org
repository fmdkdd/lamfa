# -*- org-confirm-babel-evaluate: nil; org-babel-use-quick-and-dirty-noweb-expansion: t -*-

#+PROPERTY: header-args :noweb yes

Lambda-calculus interpreter written using the interpreter pattern of the Gang of
Four.  Each AST node is an object with an ~interpret(context)~ function.

* Lambda standard
#+NAME: lambda-standard/ast-nodes
#+BEGIN_SRC js
function bot() { return BOT }
function c(e) { return {__proto__: CONST, e} }
function v(e) { return {__proto__: VAR, e} }
function fun(argName, body) { return {__proto__: FUN, argName, body} }
function app(fun, arg) { return {__proto__: APP, fun, arg} }
function ref(e) { return {__proto__: REF, e} }
function deref(e) { return {__proto__: DEREF, e} }
function assign(left, right) { return {__proto__: ASSIGN, left, right} }

var BOT = {
  execute(context) {
    return bottom }}

var CONST = {
  execute(context) {
    return this.e }}

var VAR = {
  execute(context) {
    return context.scope[this.e] }}

var FUN = {
  execute(context) {
    return new FunctionObject(this, context.scope) }}

var APP = {
  execute(context) {
    var f = this.fun.execute(context)
    var a = this.arg.execute(context)
    return f._call(a, context) }}

var REF = {
  execute(context) {
    var r = this.e.execute(context)
    var a = context.store.add(r)
    return new Address(a) }}

var DEREF = {
  execute(context) {
    var a = this.e.execute(context)
    return a.deref(context) }}
#+END_SRC

#+NAME: lambda-standard/interpreter
#+BEGIN_SRC js
var bottom = {
  toString() { return 'BOT' },
  _call(arg, context) { return this },
  deref(context) { return this },
}

function Address(a) { this.a = a }

Address.prototype.deref = function(context) {
  return context.store.retrieve(this.a)
}

function ExecutionContext(scope = {}, store = new Store()) {
  this.scope = scope
  this.store = store
}

function Store() { this.refs = [] }

Store.prototype.add = function(value) {
  this.refs.push(value)
  return this.refs.length - 1
}

Store.prototype.retrieve = function(addr) {
  return this.refs[addr]
}

function FunctionObject(node, scope) {
  this.node = node
  this.scope = scope
}

FunctionObject.prototype.toString = function() {
  return '<func>'
}

FunctionObject.prototype._call = function(arg, context) {
  var x = new ExecutionContext(Object.create(context.scope), context.store)
  x.scope[this.node.argName] = arg
  return this.node.body.execute(x)
}

function run(node) {
  return node.execute(new ExecutionContext())
}
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard/ast-nodes>>
<<lambda-standard/interpreter>>

print(run(app(fun('x', v('x')), c(42))) === 42)
print(run(bot()) === bottom)
print(run(app(bot(), c(42))) === bottom)
print(run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(run(deref(bot())) === bottom)
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true

Bottom is a singleton, since there is no need to duplicate it.

Maybe the ~FUN~ AST node object should copy the context scope rather than get a
reference to it.

The separation AST node and interpreter is not as clear, since AST nodes require
refer to AST objects, which in turn refer to value objects that were defined in
the interpreter module in the [[file:lamfa-narcissus-style.org][Narcissus style interpreter]].  Here I put
everything in the global scope.

* Lambda standard with modules
This is more like it.

#+NAME: lambda-standard-module/ast-nodes
#+BEGIN_SRC js
function bot() { return interpreter.BOT }
function c(e) { return {__proto__: interpreter.CONST, e} }
function v(e) { return {__proto__: interpreter.VAR, e} }
function fun(argName, body) { return {__proto__: interpreter.FUN, argName, body} }
function app(fun, arg) { return {__proto__: interpreter.APP, fun, arg} }
function ref(e) { return {__proto__: interpreter.REF, e} }
function deref(e) { return {__proto__: interpreter.DEREF, e} }
function assign(left, right) { return {__proto__: interpreter.ASSIGN, left, right} }
#+END_SRC

#+NAME: lambda-standard-module/AST-objects
#+BEGIN_SRC js
var BOT = {
  execute(context) {
    return bottom }}

var CONST = {
  execute(context) {
    return this.e }}

var VAR = {
  execute(context) {
    return context.scope[this.e] }}

var FUN = {
  execute(context) {
    return new FunctionObject(this, context.scope) }}

var APP = {
  execute(context) {
    var f = this.fun.execute(context)
    var a = this.arg.execute(context)
    return f._call(a, context) }}

var REF = {
  execute(context) {
    var r = this.e.execute(context)
    var a = context.store.add(r)
    return new Address(a) }}

var DEREF = {
  execute(context) {
    var a = this.e.execute(context)
    return a.deref(context) }}
#+END_SRC

#+NAME: lambda-standard-module/value-objects
#+BEGIN_SRC js
var bottom = {
  toString() { return 'BOT' },
  _call(arg, context) { return this },
  deref(context) { return this },
}

function Address(a) { this.a = a }

Address.prototype.deref = function(context) {
  return context.store.retrieve(this.a)
}

function ExecutionContext(scope = {}, store = new Store()) {
  this.scope = scope
  this.store = store
}

function Store() { this.refs = [] }

Store.prototype.add = function(value) {
  this.refs.push(value)
  return this.refs.length - 1
}

Store.prototype.retrieve = function(addr) {
  return this.refs[addr]
}

function FunctionObject(node, scope) {
  this.node = node
  this.scope = scope
}

FunctionObject.prototype.toString = function() {
  return '<func>'
}

FunctionObject.prototype._call = function(arg, context) {
  var x = new ExecutionContext(Object.create(context.scope), context.store)
  x.scope[this.node.argName] = arg
  return this.node.body.execute(x)
}
#+END_SRC

#+NAME: lambda-standard-module/interpreter
#+BEGIN_SRC js
var interpreter = (function(){
  <<lambda-standard-module/AST-objects>>

  <<lambda-standard-module/value-objects>>

  function run(node) {
    return node.execute(new ExecutionContext())
  }

  return {
    run,
    bottom, Address, Store,
    BOT, CONST, VAR, FUN, APP, REF, DEREF,
  }
}())
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-module/AST-nodes>>
<<lambda-standard-module/interpreter>>

print(interpreter.run(app(fun('x', v('x')), c(42))) === 42)
print(interpreter.run(bot()) === interpreter.bottom)
print(interpreter.run(app(bot(), c(42))) === interpreter.bottom)
print(interpreter.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(interpreter.run(deref(bot())) === interpreter.bottom)
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true

* Extending the interpreter with facets
Can we extend the definitions without copy-pasting the interpreter?

#+NAME: lambda-facet/facet-definitions
#+BEGIN_SRC js
function Facet(k, vh, vl) {
  this.k = k
  this.vh = vh
  this.vl = vl
}

function constructFacet(pc, vh, vl) {
  if (pc.length === 0)
    return vh

  var k = pc[0]
  var rest = pc.slice(1)

  if (pc[0] > 0)
    return new Facet(k, constructFacet(rest, vh, vl), vl)
  else
    return new Facet(-k, vl, constructFacet(rest, vh, vl))
}

Facet.prototype.toString = function() {
  return `<${this.k} ? ${this.vh} : ${this.vl}>`
}

function evaluateEach(v, x, f) {
  var vh, vl
  var pc = x.pc

  if (v instanceof Facet) {
    if (v.k in x.pc)
      return evaluateEach(v.vh, x, f)
    else if (-v.k in x.pc)
      return evaluateEach(v.vl, x, f)
    else {
      x.pc[v.k] = true
      vh = evaluateEach(v.vh, x, f)
      x.pc[-v.k] = true
      vl = evaluateEach(v.vl, x, f)
      x.pc = pc

      return new Facet(v.k, vh, vl)
    }
  }
  else
    return f(v, x)
}
#+END_SRC

Just changing what AST object is returned by the AST construction function is
enough to modify the interpreter.  Since now the ~interpret~ functions are
separated, we can change one without having to redefine all the others.

#+NAME: lambda-facet/ast-objects-extension
#+BEGIN_SRC js
var APP = {
  execute(context) {
    var f = this.fun.execute(context)
    var a = this.arg.execute(context)
    return evaluateEach(f, context, (f, x) => f._call(a, x)) }}

var REF = {
  execute(context) {
    var r = this.e.execute(context)
    var a = context.store.add(r)
    return constructFacet(context.pc,
                          new interpreter.Address(a),
                          interpreter.bottom) }}

var DEREF = {
  execute(context) {
    var a = this.e.execute(context)
    return evaluateEach(a, context, (a, x) => a.deref(context)) }}
#+END_SRC

#+NAME: lambda-facet/interpreter
#+BEGIN_SRC js
var interpreter = (function(){
  <<lambda-standard-module/interpreter>>

  <<lambda-facet/ast-objects-extension>>

  function ExecutionContext(scope = {}, store = new interpreter.Store(), pc = []) {
    this.scope = scope
    this.store = store
    this.pc = pc
  }

  function FunctionObject(node, scope) {
    this.node = node
    this.scope = scope
  }

  FunctionObject.prototype.toString = function() {
    return '<func>'
  }

  FunctionObject.prototype._call = function(arg, x) {
    var x2 = new ExecutionContext(Object.create(x.scope), x.store, x.pc)
    x2.scope[this.node.argName] = arg
    return this.node.body.execute(x2)
  }

  var FUN = {
    execute(context) {
      return new FunctionObject(this, context.scope) }}

  function run(ast) {
    return ast.execute(new ExecutionContext())
  }

  function runWithPC(ast, pc) {
    var x = new ExecutionContext()
    x.pc = pc
    return ast.execute(x)
  }

  return {
    __proto__: interpreter,
    APP, REF, DEREF, FUN,
    run,
    runWithPC,
  }
}())
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-module/ast-nodes>>
<<lambda-facet/facet-definitions>>
<<lambda-facet/interpreter>>

print(interpreter.run(app(fun('x', v('x')), c(42))) === 42)
print(interpreter.run(bot()) === interpreter.bottom)
print(interpreter.run(app(bot(), c(42))) === interpreter.bottom)
print(interpreter.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(interpreter.run(deref(bot())) === interpreter.bottom)

print(interpreter.runWithPC(
  app(fun('x', deref(v('x'))),
      ref(c(42))),
  [1]))
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true
: <1 ? 42 : BOT>

Look at all I’ve got to override!  For the AST objects, it’s okay, but for the
value objects we need to add the ~pc~ field to ~ExecutionContext~, and that
leads to redefining ~FunctionObject~, which in turn means we need to redefine
the FUN AST object just to update the binding.

Okay, maybe /subclassing/ ~FunctionObject~ was enough to do it.  But still, I
should not have to redefine FUN.  This is caused by the premature coupling
between ~FUN~ and ~FunctionObject~.  There are multiple ways to solve this
coupling: parameterize the ~interpreter~ module for the value objects:

: var interpreter = function(FunctionObject) { ... }

or define them outside the module and make an indirect call:

: return new valueObjects.FunctionObject(...)

or use a factory:

: return interpreter.mkFunctionObject(...)

All amount to the same, really.  It’s just adding a level of indirection to the
reference to ~FunctionObject~ in order to be able to change it in the facet
interpreter.  Note that factories are unnecessary in JavaScript, since we can
directly pass constructors as values.

Actually, we can see that the change to ~FunctionObject~ is just passing an
additional argument to ~ExecutionContext~, so we could make the
~ExecutionContext~ constructor inherit from a parent context to avoid redefining
~FunctionObject~.  Still, we would need to inject this new ~ExecutionContext~
into the new version of the interpreter.

But we need to adapt the standard interpreter for that to work.

* Lambda standard Mk3

#+NAME: lambda-standard-mk3/AST-nodes
#+BEGIN_SRC js
function bot() { return interpreter.BOT }
function c(e) { return {__proto__: interpreter.CONST, e} }
function v(e) { return {__proto__: interpreter.VAR, e} }
function fun(argName, body) { return {__proto__: interpreter.FUN, argName, body} }
function app(fun, arg) { return {__proto__: interpreter.APP, fun, arg} }
function ref(e) { return {__proto__: interpreter.REF, e} }
function deref(e) { return {__proto__: interpreter.DEREF, e} }
function assign(left, right) { return {__proto__: interpreter.ASSIGN, left, right} }
#+END_SRC

#+NAME: lambda-standard-mk3/AST-objects
#+BEGIN_SRC js
var BOT = {
  execute(context) {
    return interpreter.bottom }}

var CONST = {
  execute(context) {
    return this.e }}

var VAR = {
  execute(context) {
    return context.scope[this.e] }}

var FUN = {
  execute(context) {
    return new interpreter.FunctionObject(this, context.scope) }}

var APP = {
  execute(context) {
    var f = this.fun.execute(context)
    var a = this.arg.execute(context)
    return f._call(a, context) }}

var REF = {
  execute(context) {
    var r = this.e.execute(context)
    var a = context.store.add(r)
    return new interpreter.Address(a) }}

var DEREF = {
  execute(context) {
    var a = this.e.execute(context)
    return a.deref(context) }}
#+END_SRC

#+NAME: lambda-standard-mk3/value-objects
#+BEGIN_SRC js
var bottom = {
  toString() { return 'BOT' },
  _call(arg, context) { return this },
  deref(context) { return this },
}

function Address(a) { this.a = a }

Address.prototype.deref = function(context) {
  return context.store.retrieve(this.a)
}

function ExecutionContext(scope = {}, store = new Store()) {
  this.scope = scope
  this.store = store
}

function Store() { this.refs = [] }

Store.prototype.add = function(value) {
  this.refs.push(value)
  return this.refs.length - 1
}

Store.prototype.retrieve = function(addr) {
  return this.refs[addr]
}

function FunctionObject(node, scope) {
  this.node = node
  this.scope = scope
}

FunctionObject.prototype.toString = function() {
  return '<func>'
}

FunctionObject.prototype._call = function(arg, x) {
  var x2 = new interpreter.ExecutionContext(Object.create(x.scope), x.store)
  x2.scope[this.node.argName] = arg
  return this.node.body.execute(x2)
}
#+END_SRC

#+NAME: lambda-standard-mk3/interpreter
#+BEGIN_SRC js
var interpreter = (function(){
  <<lambda-standard-mk3/AST-objects>>
  <<lambda-standard-mk3/value-objects>>

  function run(node) {
    return node.execute(new interpreter.ExecutionContext())
  }

  return {
    BOT, CONST, VAR, FUN, APP, REF, DEREF,
    bottom, Address, ExecutionContext, Store, FunctionObject,
    run,
  }
}())
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-mk3/AST-objects>>
<<lambda-standard-mk3/value-objects>>
<<lambda-standard-mk3/interpreter>>
<<lambda-standard-mk3/AST-nodes>>

print(interpreter.run(app(fun('x', v('x')), c(42))) === 42)
print(interpreter.run(bot()) === interpreter.bottom)
print(interpreter.run(app(bot(), c(42))) === interpreter.bottom)
print(interpreter.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(interpreter.run(deref(bot())) === interpreter.bottom)
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true

And now, to add the facets changes.

#+NAME: lambda-facets-mk3/interpreter
#+BEGIN_SRC js
var interpreter = (function(){
  <<lambda-standard-mk3/interpreter>>

  var APP = {
    execute(context) {
      var f = this.fun.execute(context)
      var a = this.arg.execute(context)
      return evaluateEach(f, context, (f, x) => f._call(a, x)) }}
  interpreter.APP = APP

  var REF = {
    execute(context) {
      var r = this.e.execute(context)
      var a = context.store.add(r)
      return constructFacet(context.pc,
                            new interpreter.Address(a),
                            interpreter.bottom) }}
  interpreter.REF = REF

  var DEREF = {
    execute(context) {
      var a = this.e.execute(context)
      return evaluateEach(a, context, (a, x) => a.deref(context)) }}
  interpreter.DEREF = DEREF

  function ExecutionContext(scope = {}, store = new interpreter.Store(), pc = []) {
    this.scope = scope
    this.store = store
    this.pc = pc
  }
  interpreter.ExecutionContext = ExecutionContext

  // Save current value to avoid infinite recursion
  var FunctionObject = interpreter.FunctionObject
  function FunctionObjectF(...args) {
    FunctionObject.apply(this, args)
  }
  FunctionObjectF.prototype = Object.create(FunctionObject.prototype)

  FunctionObjectF.prototype._call = function(arg, x) {
    var x2 = new interpreter.ExecutionContext(Object.create(x.scope), x.store, x.pc)
    x2.scope[this.node.argName] = arg
    return this.node.body.execute(x2)
  }
  interpreter.FunctionObject = FunctionObjectF

  function run(ast) {
    return ast.execute(new interpreter.ExecutionContext())
  }
  interpreter.run = run

  function runWithPC(ast, pc) {
    var x = new interpreter.ExecutionContext()
    x.pc = pc
    return ast.execute(x)
  }


  return {
    __proto__: interpreter,
    runWithPC,
  }
}())
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-mk3/AST-nodes>>
<<lambda-facet/facet-definitions>>
<<lambda-facets-mk3/interpreter>>

print(interpreter.run(app(fun('x', v('x')), c(42))) === 42)
print(interpreter.run(bot()) === interpreter.bottom)
print(interpreter.run(app(bot(), c(42))) === interpreter.bottom)
print(interpreter.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(interpreter.run(deref(bot())) === interpreter.bottom)

print(interpreter.runWithPC(
  app(fun('x', deref(v('x'))),
      ref(c(42))),
  [1]))
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true
: <1 ? 42 : BOT>

Now only the necessary lines are changed.  We could refactor ~ExecutionContext~
in the standard interpreter take a parent context and copy all its properties,
and avoid redefining the ~FunctionObject~.

The template to change the interpreter is:
1. Take the original interpreter (as it is a singleton, though it would be easy
   to change it to a factory: just don’t call the IIFE).
2. Define new pieces.
3. Change the references in the interpreter object.
4. Return the interpreter object (or an extended version, with additional
   exports).

This does not break encapsulation of the interpreter module (though you do have
to peek inside the module to know what to change).  But it’s still a bit
confusing since we have multiple objects that have /slightly different/
behavior, but have the same name...

Advantage of this method is that we can use it to change dynamically the
behavior of any instance of an interpreter.  And restore it.

An alternative would be to consider the facets evaluation as a different
~execute~ method, ~executeFacets~, which delegates to ~execute~ by default.
Then, have variants of AST node creators, and a ~runFacets~ that calls
~executeFacets~.  This way, we can create as many interpreters as there are
variants of evaluation.

We can still change the behavior of evaluation dynamically with a single
reference to the current interpreter (like a State pattern).

: interpreter = interpreterStd | interpreterFacets | ...

Remark: since we actually redefine what ~interpreter~ means, we are also
changing the meaning of programs created after this change through AST node
calls, but not of the programs created before this redefinition.  This is a bit
troublesome.

* Pure object interpreter
Actually, the indirection that we get by prefixing calls to the definitions made
inside the interpreter (~ExecutionContext~, ~FUN~, ...), we can obtain by using
getters.  That is, message passing instead of direct reference.

Since using a closure in the module pattern is just to prevent overriding the
definitions, and we /do need/ to override the definitions, we can use define the
interpreter as an object, which would make the overriding much more convenient
and straightforward.

#+NAME: lambda-standard-object/interpreter
#+BEGIN_SRC js
<<nested-object>>

var stdProto = derive(recObject, {
  BOT: nest('interp', {
    execute(context) {
      return this.interp.bottom }}),

  CONST: nest('interp', {
    new(e) {
      return derive(this, {e}) },
    execute(context) {
      return this.e }}),

  VAR: nest('interp', {
    new(e) {
      return derive(this, {e}) },
    execute(context) {
      return context.scope[this.e] }}),

  FUN: nest('interp', {
    new(argName, body) {
      return derive(this, {argName, body}) },
    execute(context) {
      return this.interp.FunctionObject.new(this, context.scope) }}),

  APP: nest('interp', {
    new(fun, arg) {
      return derive(this, {fun, arg}) },
    execute(context) {
      var f = this.fun.execute(context)
      var a = this.arg.execute(context)
      return f._call(a, context) }}),

  REF: nest('interp', {
    new(e) {
      return derive(this, {e}) },
    execute(context) {
      var r = this.e.execute(context)
      var a = context.store.add(r)
      return this.interp.Address.new(a) }}),

  DEREF: nest('interp', {
    new(e) {
      return derive(this, {e}) },
    execute(context) {
      var a = this.e.execute(context)
      return a.deref(context) }}),

  bottom: {
    _call(arg, context) { return this },
    deref(context) { return this },
    toString() { return 'BOT' },
  },

  Address: {
    new(a) { return derive(this, {a}) },
    deref(context) { return context.store.retrieve(this.a) },
    toString() { return `#${this.a}` },
  },

  ExecutionContext: nest('interp', {
    new(scope = {}, store = this.interp.Store.new()) {
      return derive(this, {scope, store})
    },
  }),

  Store: {
    new() {return derive(this, {refs: []}) },
    add(value) {
      this.refs.push(value)
      return this.refs.length - 1
    },
    retrieve(addr) { return this.refs[addr] },
  },

  FunctionObject: nest('interp', {
    new(node, scope) { return derive(this, {node, scope}) },
    _call(arg, x) {
      var x2 = this.interp.ExecutionContext.new(Object.create(x.scope), x.store)
      x2.scope[this.node.argName] = arg
      return this.node.body.execute(x2)
    },
    toString() { return '<func>' },
  }),

  run(node) {
    return node.execute(this.ExecutionContext.new())
  },
})

var std = stdProto.new()
#+END_SRC

#+NAME: lambda-standard-object/AST-nodes
#+BEGIN_SRC js
function bot() { return std.BOT }
function c(e) { return std.CONST.new(e) }
function v(e) { return std.VAR.new(e) }
function fun(argName, body) { return std.FUN.new(argName, body) }
function app(fun, arg) { return std.APP.new(fun, arg) }
function ref(e) { return std.REF.new(e) }
function deref(e) { return std.DEREF.new(e) }
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-object/interpreter>>
<<lambda-standard-object/AST-nodes>>

print(std.run(app(fun('x', v('x')), c(42))) === 42)
print(std.run(bot()) === std.bottom)
print(std.run(app(bot(), c(42))) === std.bottom)
print(std.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(std.run(deref(bot())) === std.bottom)
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true

#+NAME: lambda-facets-object/interpreter
#+BEGIN_SRC js :results output stderr
<<nested-object>>
<<lambda-standard-object/interpreter>>
<<lambda-facet/facet-definitions>>

var fctProto = derive(stdProto, {
  APP: derive(stdProto.APP, {
    execute(context) {
      var f = this.fun.execute(context)
      var a = this.arg.execute(context)
      return evaluateEach(f, context, (f, x) => f._call(a, x)) }}),

  REF: derive(stdProto.REF, {
    execute(context) {
      var r = this.e.execute(context)
      var a = context.store.add(r)
      return constructFacet(context.pc,
                            this.interp.Address.new(a),
                            this.interp.bottom) }}),

  DEREF: derive(stdProto.DEREF, {
    execute(context) {
      var a = this.e.execute(context)
      return evaluateEach(a, context, (a, x) => a.deref(context)) }}),


  ExecutionContext: derive(stdProto.ExecutionContext, {
    new(scope = {}, store = this.interp.Store.new(), pc = []) {
      return derive(this, {scope, store, pc})
    }
  }),

  FunctionObject: derive(stdProto.FunctionObject, {
    _call(arg, x) {
      var x2 = this.interp.ExecutionContext.new(Object.create(x.scope),
                                                x.store, x.pc)
      x2.scope[this.node.argName] = arg
      return this.node.body.execute(x2)
    }}),

  runWithPC(ast, pc) {
    var x = this.ExecutionContext.new()
    x.pc = pc
    return ast.execute(x)
  },
})

var fct = fctProto.new()
#+END_SRC

#+NAME: lambda-facets-object/AST-nodes
#+BEGIN_SRC js
function bot() { return fct.BOT }
function c(e) { return fct.CONST.new(e) }
function v(e) { return fct.VAR.new(e) }
function fun(argName, body) { return fct.FUN.new(argName, body) }
function app(fun, arg) { return fct.APP.new(fun, arg) }
function ref(e) { return fct.REF.new(e) }
function deref(e) { return fct.DEREF.new(e) }
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-facets-object/interpreter>>
<<lambda-facets-object/AST-nodes>>

print(fct.run(app(fun('x', v('x')), c(42))) === 42)
print(fct.run(bot()) === std.bottom)
print(fct.run(app(bot(), c(42))) === std.bottom)
print(fct.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(fct.run(deref(bot())) === std.bottom)

print(fct.runWithPC(
  app(fun('x', deref(v('x'))),
      ref(c(42))),
  [1]))
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true
: <1 ? 42 : BOT>

So it’s actually not that difficult to change the interpreter if it follows a
style that is amenable to extension.  The trick is, of course, that we might
/not want/ or might not be /able to/ refactor the whole interpreter as we did
there.  In this case, we must find mechanisms to override the protection of the
module pattern.

** Sidebar: nested objects
Problem: ~CONST~ is an object defined inside ~std~, and so is
~ExecutionContext~.  A method inside ~CONST~ wants to refer to
~ExecutionContext~.

: std.ExecutionContext

does the job.  But, now we derive ~fct~ from ~std~ and override
~ExecutionContext~ in ~fct~.  Since we can call ~fct.CONST~, we would like it to
refer to ~fct.ExecutionContext~.  In other words, we would like ~fct.CONST~ to
follow the receiver.

If objects are not nested, this is the behavior we want:

#+BEGIN_SRC js :results output stderr
var std = {
  C() { return this.ExecutionContext() },
  ExecutionContext() { return 'ok' },
}

print(std.C())

var fct = {
  __proto__: std,
  ExecutionContext() { return 'super ok' }
}

print(fct.C())
#+END_SRC

#+RESULTS:
: ok
: super ok

Just plain dynamic binding: ~C~ is found on the prototype of ~fct~, but ~this~
is the receiver of the ~C~ call, which is ~fct~, so ~fct.ExecutionContext~ is
used in the end.

But we have nested objects, and using ~std~ does not work in ~fct.C~:

#+BEGIN_SRC js :results output stderr
var std = {
  C: {
    m() { return std.f() }},

  f() { return 'ok' },
}

print(std.C.m())

var fct = {
  __proto__: std,
  f() { return 'super ok' }
}

print(fct.C.m())
#+END_SRC

#+RESULTS:
: ok
: ok

For once, we could do it easily in Java with ~std.this~, which refers to the
instance of ~std~ associated with the instance of the nested class.

But in JavaScript, there is absolutely no difference between defining ~C~ inside
~std~ or outside.  Defining it inside does not implicitly define a link between
the two:

#+BEGIN_SRC js :results output stderr
var C = {m() { return std.f() }}

var std = {
  f() { return 'ok' },
  C: C,
}

print(std.C.m())

var fct = {
  __proto__: std,
  f() { return 'super ok' }
}

print(fct.C.m())
#+END_SRC

#+RESULTS:
: ok
: ok

In fact, ~std.C.m()~ and ~fct.C.m()~ and ~C.m()~ are totally equivalent calls.
If we want the first two to give different answers, ~C~ must be a different
object.  Or we can get tricky with getters.

#+BEGIN_SRC js :results output stderr
var C = {m() { return this.interp.f() }}

var std = {
  f() { return 'ok' },
  get C() {
    C.interp = this
    return C
  }
}

print(std.C.m())

var fct = {
  __proto__: std,
  f() { return 'super ok' }
}

print(fct.C.m())
#+END_SRC

#+RESULTS:
: ok
: super ok

As ~this~ is a hidden argument of function that is bound to the receiver, we can
view ~this.interp~ as an additional special argument, bound to the receiver of
the receiver.  We don’t have any syntax to pass this extra special argument, but
could make it explicit.

#+BEGIN_SRC js :results output stderr
var C = {m(interp) { return interp.f() }}

var std = {
  f() { return 'ok' },
  C: C,
}

print(std.C.m(std))

var fct = {
  __proto__: std,
  f() { return 'super ok' }
}

print(fct.C.m(fct))
#+END_SRC

#+RESULTS:
: ok
: super ok

But then, once again the ~std~ prefix is useless.

Rather than having to pass this argument to all calls to ~m~, if ~C~ has
instances, we can attach the interpreter at their creation:

#+BEGIN_SRC js :results output stderr
var std = {
  CONST: {
    new(interp, e) { return {__proto__: this, e, interp}},
    execute() { return this.interp.ExecutionContext.new() },
    toString() { return this.e },
  },

  ExecutionContext: {
    new() { return 'ok' }
  },
}

print(std.CONST.new(std, 42).execute())

function c(e) { return std.CONST.new(std, e) }

print(c(42).execute())

var fct = {
  __proto__: std,
  ExecutionContext: {
    new() { return 'super ok' }
  },
}

print(fct.CONST.new(fct, 42).execute())

function cF(e) { return fct.CONST.new(fct, e) }

print(cF(42).execute())
#+END_SRC

#+RESULTS:
: ok
: ok
: super ok
: super ok

This is quite explicit and straightforward (no tricks).  There could be an issue
of coherence: if multiple objects like ~C~ are defined inside ~std~, we would
like all their derivatives to point to the same interpreter object.  Here, this
is ensured only by using constructors like ~c~ and ~cF~.

The Java solution is to have one instance of ~C~ for ~std~, and another for
~fct~, and each instance of ~C~ has a link to the interpreter it is defined in.
We can simulate that in two ways: link each instance of ~C~ to its enclosing
object at their creation, through the ~new~ call, as above, or use the getter
trick.

The getter solution fails when we can create instances of ~C~ though.  Since
the link to the enclosing object happens through the prototype, which means
there can only be one interpreter linked at a time for all ~C~ objects.

#+BEGIN_SRC js :results output stderr
var C = {
  new(e) { return {__proto__: this, e}},
  m() { return this.interp.f(this.e) }}

var std = {
  f(e) { return 'ok' + e },
  get C() {
    C.interp = this
    return C
  }
}

print(std.C.new(42).m())

var fct = {
  __proto__: std,
  f(e) { return 'super ok' + e }
}

print(fct.C.new(42).m())

var c = fct.C.new(42)
print(std.C.new(32).m())
print(c.m())
#+END_SRC

#+RESULTS:
: ok42
: super ok42
: ok32
: ok42

So the only robust solution is to make the link at creation time.

Seems even the ECMASCript 2015 specification has not refined sugar for nested
classes.  So putting if you put an object inside another, you have to make the
links explicit.

#+BEGIN_SRC js :results output stderr
var C = {
  new(e) { return {__proto__: this, e}},
  m() { return this.interp.f(this.e) }}

var std = {
  f(e) { return 'std f ' + e },
  closeNested() {
    this.C = {__proto__: C, interp: this}
    return this
  }
}.closeNested()

print(std.C.new(42).m())

var fct = {
  __proto__: std,
  f(e) { return 'fct f' + e }
}.closeNested()

print(fct.C.new(42).m())

var c = std.C.new(42)
var cF = fct.C.new(10)
print(c.m())
print(cF.m())
#+END_SRC

#+RESULTS:
: std f 42
: fct f42
: std f 42
: fct f10

Aha!  With the above version, it is clear that ~C~ is an object independent from
~std~ or ~fct~, but still coupled to one.  Then, ~std.C~ is just a derivative of
~C~ with the right ~interp~ reference.  So is ~fct.C~ after the call to
~closeNested~.  We have the following prototype chain:

: C <- std.C
: ^- fct.C

So, if we want to derive ~C~ in ~fct~, we need:

: C <- C’ <- fct.C
: ^
: |
: std.C

#+BEGIN_SRC js :results output stderr
var C = {
  new(e) { return {__proto__: this, e}},
  m() { return this.interp.f(this.e) }}

var std = {
  f(e) { return 'std f ' + e },
  closeNested() {
    this.C = {__proto__: C, interp: this}
    return this
  }
}.closeNested()

print(std.C.new(42).m())

var CF = {
  __proto__: C,
  m() { return this.interp.f(this.e + this.e)}}

var fct = {
  __proto__: std,
  f(e) { return 'fct f' + e },
  closeNested() {
    this.C = {__proto__: CF, interp: this}
    return this
  },
}.closeNested()

print(fct.C.new(42).m())

var c = std.C.new(42)
var cF = fct.C.new(10)
print(c.m())
print(cF.m())
#+END_SRC

#+RESULTS:
: std f 42
: fct f84
: std f 42
: fct f20

The boilerplate is a bit unfortunate.  Wish I had macros here.

Looks like ~std~ tries to be two things at once: a /template/ for an ~std~
/instance/ in which the relationship between ~std~ and ~C~ is declared.  The
instance has a ~C~ derivative with the relationship in place.  When ~fct~ comes,
it also needs to derive the ~std~ template in order to generate the ~fct~
instance, and tie the knot by recreating a ~C~ object with the right reference
to ~interp~.

#+BEGIN_SRC js :results output stderr
var stdProto = {
  new() {
    var o = Object.create(this)
    o.C = {__proto__: this.C, interp: o}
    return o
  },
  C: {
    new(e) { return {__proto__: this, e } },
    m() { return this.interp.f(this.e) },
  },
  f(e) { return 'stdProto.f' + e },
}

var std = stdProto.new()

print(std.C.new(42).m())

var fctProto = {
  __proto__: stdProto,

  C: {
    __proto__: stdProto.C,
    m() { return this.interp.f(this.e + this.e) },
  },

  f(e) { return 'fctProto.f' + e },
}

var fct = fctProto.new()

print(fct.C.new(10).m())
#+END_SRC

#+RESULTS:
: stdProto.f42
: fctProto.f20

So I think the right way to think of this is: we have objects that share a
dependency that cannot be expressed at declaration time using object literals.
So, we must use dedicated constructors that will enforce this relationship.
Here, the constructor is simply ~stdProto.new~.

We get the same behavior as the following Java code:

#+BEGIN_SRC java :classname Std :results output
class Std {
  public class C {
    int e;
    public C(int e) { this.e = e; }
    public String m() { return Std.this.f(e); }
  }

  public String f(int e) { return "Std.f " + e; }

  public static void main(String args[]) {
    Std.C c = (new Std()).new C(42);
    System.out.println(c.m());

    Fct.C cf = (new Fct()).new C(10);
    System.out.println(cf.m());
  }
}

class Fct extends Std {
  public class C extends Std.C {
     public C(int e) { super(e); }
     public String m() { return Fct.this.f(e + e); }
  }
  public String f(int e) { return "Fct.f " + e; }
}
#+END_SRC

#+RESULTS:
: Std.f 42
: Fct.f 20

Finally, we need to automatically build the ~new~ from the list of all nested
objects that must keep in sync:

#+BEGIN_SRC js :results output stderr
var nested = {}
function nest(obj) { return {nested, obj} }
function isNested(o) { return o.nested === nested }
function nestedObj(o) { return o.obj }
function derive(parent, obj) {
  if (isNested(parent))
    parent = nestedObj(parent)
  Object.setPrototypeOf(obj, parent)
  return obj
}

var recObject = {
  new() {
    var o = Object.create(this)
    // Derive all nested objects (even inherited from the prototype)
    // and set their `interp` link.
    for (var p in this) {
      if (isNested(this[p])) {
        o[p] = derive(nestedObj(this[p]), {interp: o}) }}
    return o
  },
}

var stdProto = derive(recObject, {
  C: nest({
    new(e) { return {__proto__: this, e } },
    m() { return this.interp.f(this.e) },
  }),
  f(e) { return 'stdProto.f' + e },
})

var std = stdProto.new()

print(std.C.new(42).m())

var fctProto = derive(stdProto, {
  C: nest(derive(stdProto.C, {
    m() { return this.interp.f(this.e + this.e) },
  })),

  f(e) { return 'fctProto.f' + e },
})

var fct = fctProto.new()

print(fct.C.new(10).m())
#+END_SRC

#+RESULTS:
: stdProto.f42
: fctProto.f20

With ~nest~ I can declare nested objects in ~stdProto~, and when ~stdProto.new~
is called, instances are derived from all the nested objects of ~stdProto~ and
their ~interp~ link is set to ~std~.  Now, I can derive ~stdProto~ into
~fctProto~ and redefine only the ~m~ method of ~C~.

NB: the ~interp~ name is fixed, but could be an argument to ~nest~, which would
make the solution generic for nested objects.

We can go improve things further slightly.  Here we use ~derive~ instead of
setting the ~__proto__~ link because ~derive~ goes around nested objects:
~derive(stdProto.C)~ will find the ~C~ object we want to derive from, not the
wrapper created by ~nest~.  However, since ~stdProto.C~ is declared as a nested
object, it might not make sense to be able to un-nest it in ~fctProto~.  So
maybe ~derive~ can auto-nest:

#+NAME: nested-object
#+BEGIN_SRC js
var nested = {}
function nest(selfName, obj) { return {nested, selfName, obj} }
function isNested(o) { return o.nested === nested }
function nestedObj(o) { return o.obj }
function nestedSelfName(o) { return o.selfName }
function derive(parent, obj) {
  if (isNested(parent)) {
    Object.setPrototypeOf(obj, nestedObj(parent))
    obj.super = nestedObj(parent)
    return nest(nestedSelfName(parent), obj)
  }
  else {
    Object.setPrototypeOf(obj, parent)
    obj.super = parent
    return obj
  }
}

var recObject = {
  new() {
    var o = Object.create(this)
    // Derive all nested objects (even inherited from the prototype)
    // and set their `interp` link.
    for (var p in this) {
      if (isNested(this[p])) {
        o[p] = derive(nestedObj(this[p]),
                      {[nestedSelfName(this[p])]: o}) }}
    return o
  },
}
#+END_SRC

and then we get the quite declarative:

#+BEGIN_SRC js :results output stderr
<<nested-object>>

var stdProto = derive(recObject, {
  C: nest('interp', {
    new(e) { return {__proto__: this, e } },
    m() { return this.interp.f(this.e) },
  }),
  f(e) { return 'stdProto.f' + e },
})

var std = stdProto.new()

print(std.C.new(42).m())

var fctProto = derive(stdProto, {
  C: derive(stdProto.C, {
    m() { return this.interp.f(this.e + this.e) },
  }),

  f(e) { return 'fctProto.f' + e },
})

var fct = fctProto.new()

print(fct.C.new(10).m())
#+END_SRC

#+RESULTS:
: stdProto.f42
: fctProto.f20

One last stealth addition to [[nested-object]] above is the ~super~ property on a
deriving object.  Because of ~nest~, we cannot rely on using ~__proto__~ to find
out our parent, ~derive~ sets up a correct link.
