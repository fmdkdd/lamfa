# -*- org-confirm-babel-evaluate: nil; org-babel-use-quick-and-dirty-noweb-expansion: t -*-

#+PROPERTY: header-args :noweb yes

Lambda-calculus interpreter written using the interpreter pattern of the Gang of
Four.  Each AST node is an object with an ~interpret(context)~ function.

* Lambda standard
#+NAME: lambda-standard/ast-nodes
#+BEGIN_SRC js
function bot() { return BOT }
function c(e) { return {__proto__: CONST, e} }
function v(e) { return {__proto__: VAR, e} }
function fun(argName, body) { return {__proto__: FUN, argName, body} }
function app(fun, arg) { return {__proto__: APP, fun, arg} }
function ref(e) { return {__proto__: REF, e} }
function deref(e) { return {__proto__: DEREF, e} }
function assign(left, right) { return {__proto__: ASSIGN, left, right} }

var BOT = {
  execute(context) {
    return bottom }}

var CONST = {
  execute(context) {
    return this.e }}

var VAR = {
  execute(context) {
    return context.scope[this.e] }}

var FUN = {
  execute(context) {
    return new FunctionObject(this, context.scope) }}

var APP = {
  execute(context) {
    var f = this.fun.execute(context)
    var a = this.arg.execute(context)
    return f._call(a, context) }}

var REF = {
  execute(context) {
    var r = this.e.execute(context)
    var a = context.store.add(r)
    return new Address(a) }}

var DEREF = {
  execute(context) {
    var a = this.e.execute(context)
    return a.deref(context) }}
#+END_SRC

#+NAME: lambda-standard/interpreter
#+BEGIN_SRC js
var bottom = {
  toString() { return 'BOT' },
  _call(arg, context) { return this },
  deref(context) { return this },
}

function Address(a) { this.a = a }

Address.prototype.deref = function(context) {
  return context.store.retrieve(this.a)
}

function ExecutionContext(scope = {}, store = new Store()) {
  this.scope = scope
  this.store = store
}

function Store() { this.refs = [] }

Store.prototype.add = function(value) {
  this.refs.push(value)
  return this.refs.length - 1
}

Store.prototype.retrieve = function(addr) {
  return this.refs[addr]
}

function FunctionObject(node, scope) {
  this.node = node
  this.scope = scope
}

FunctionObject.prototype.toString = function() {
  return '<func>'
}

FunctionObject.prototype._call = function(arg, context) {
  var x = new ExecutionContext(Object.create(context.scope), context.store)
  x.scope[this.node.argName] = arg
  return this.node.body.execute(x)
}

function run(node) {
  return node.execute(new ExecutionContext())
}
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard/ast-nodes>>
<<lambda-standard/interpreter>>

print(run(app(fun('x', v('x')), c(42))) === 42)
print(run(bot()) === bottom)
print(run(app(bot(), c(42))) === bottom)
print(run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(run(deref(bot())) === bottom)
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true

Bottom is a singleton, since there is no need to duplicate it.

Maybe the ~FUN~ AST node object should copy the context scope rather than get a
reference to it.

The separation AST node and interpreter is not as clear, since AST nodes require
refer to AST objects, which in turn refer to value objects that were defined in
the interpreter module in the [[file:lamfa-narcissus-style.org][Narcissus style interpreter]].  Here I put
everything in the global scope.

* Lambda standard with modules
This is more like it.

#+NAME: lambda-standard-module/ast-nodes
#+BEGIN_SRC js
function bot() { return interpreter.BOT }
function c(e) { return {__proto__: interpreter.CONST, e} }
function v(e) { return {__proto__: interpreter.VAR, e} }
function fun(argName, body) { return {__proto__: interpreter.FUN, argName, body} }
function app(fun, arg) { return {__proto__: interpreter.APP, fun, arg} }
function ref(e) { return {__proto__: interpreter.REF, e} }
function deref(e) { return {__proto__: interpreter.DEREF, e} }
function assign(left, right) { return {__proto__: interpreter.ASSIGN, left, right} }
#+END_SRC

#+NAME: lambda-standard-module/AST-objects
#+BEGIN_SRC js
var BOT = {
  execute(context) {
    return bottom }}

var CONST = {
  execute(context) {
    return this.e }}

var VAR = {
  execute(context) {
    return context.scope[this.e] }}

var FUN = {
  execute(context) {
    return new FunctionObject(this, context.scope) }}

var APP = {
  execute(context) {
    var f = this.fun.execute(context)
    var a = this.arg.execute(context)
    return f._call(a, context) }}

var REF = {
  execute(context) {
    var r = this.e.execute(context)
    var a = context.store.add(r)
    return new Address(a) }}

var DEREF = {
  execute(context) {
    var a = this.e.execute(context)
    return a.deref(context) }}
#+END_SRC

#+NAME: lambda-standard-module/value-objects
#+BEGIN_SRC js
var bottom = {
  toString() { return 'BOT' },
  _call(arg, context) { return this },
  deref(context) { return this },
}

function Address(a) { this.a = a }

Address.prototype.deref = function(context) {
  return context.store.retrieve(this.a)
}

function ExecutionContext(scope = {}, store = new Store()) {
  this.scope = scope
  this.store = store
}

function Store() { this.refs = [] }

Store.prototype.add = function(value) {
  this.refs.push(value)
  return this.refs.length - 1
}

Store.prototype.retrieve = function(addr) {
  return this.refs[addr]
}

function FunctionObject(node, scope) {
  this.node = node
  this.scope = scope
}

FunctionObject.prototype.toString = function() {
  return '<func>'
}

FunctionObject.prototype._call = function(arg, context) {
  var x = new ExecutionContext(Object.create(context.scope), context.store)
  x.scope[this.node.argName] = arg
  return this.node.body.execute(x)
}
#+END_SRC

#+NAME: lambda-standard-module/interpreter
#+BEGIN_SRC js
var interpreter = (function(){
  <<lambda-standard-module/AST-objects>>

  <<lambda-standard-module/value-objects>>

  function run(node) {
    return node.execute(new ExecutionContext())
  }

  return {
    run,
    bottom, Address, Store,
    BOT, CONST, VAR, FUN, APP, REF, DEREF,
  }
}())
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-module/AST-nodes>>
<<lambda-standard-module/interpreter>>

print(interpreter.run(app(fun('x', v('x')), c(42))) === 42)
print(interpreter.run(bot()) === interpreter.bottom)
print(interpreter.run(app(bot(), c(42))) === interpreter.bottom)
print(interpreter.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(interpreter.run(deref(bot())) === interpreter.bottom)
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true

* Extending the interpreter with facets
Can we extend the definitions without copy-pasting the interpreter?

#+NAME: lambda-facet/facet-definitions
#+BEGIN_SRC js
function Facet(k, vh, vl) {
  this.k = k
  this.vh = vh
  this.vl = vl
}

function constructFacet(pc, vh, vl) {
  if (pc.length === 0)
    return vh

  var k = pc[0]
  var rest = pc.slice(1)

  if (pc[0] > 0)
    return new Facet(k, constructFacet(rest, vh, vl), vl)
  else
    return new Facet(-k, vl, constructFacet(rest, vh, vl))
}

Facet.prototype.toString = function() {
  return `<${this.k} ? ${this.vh} : ${this.vl}>`
}

function evaluateEach(v, x, f) {
  var vh, vl
  var pc = x.pc

  if (v instanceof Facet) {
    if (v.k in x.pc)
      return evaluateEach(v.vh, x, f)
    else if (-v.k in x.pc)
      return evaluateEach(v.vl, x, f)
    else {
      x.pc[v.k] = true
      vh = evaluateEach(v.vh, x, f)
      x.pc[-v.k] = true
      vl = evaluateEach(v.vl, x, f)
      x.pc = pc

      return new Facet(v.k, vh, vl)
    }
  }
  else
    return f(v, x)
}
#+END_SRC

Just changing what AST object is returned by the AST construction function is
enough to modify the interpreter.  Since now the ~interpret~ functions are
separated, we can change one without having to redefine all the others.

#+NAME: lambda-facet/ast-objects-extension
#+BEGIN_SRC js
var APP = {
  execute(context) {
    var f = this.fun.execute(context)
    var a = this.arg.execute(context)
    return evaluateEach(f, context, (f, x) => f._call(a, x)) }}

var REF = {
  execute(context) {
    var r = this.e.execute(context)
    var a = context.store.add(r)
    return constructFacet(context.pc,
                          new interpreter.Address(a),
                          interpreter.bottom) }}

var DEREF = {
  execute(context) {
    var a = this.e.execute(context)
    return evaluateEach(a, context, (a, x) => a.deref(context)) }}
#+END_SRC

#+NAME: lambda-facet/interpreter
#+BEGIN_SRC js
var interpreter = (function(){
  <<lambda-standard-module/interpreter>>

  <<lambda-facet/ast-objects-extension>>

  function ExecutionContext(scope = {}, store = new interpreter.Store(), pc = []) {
    this.scope = scope
    this.store = store
    this.pc = pc
  }

  function FunctionObject(node, scope) {
    this.node = node
    this.scope = scope
  }

  FunctionObject.prototype.toString = function() {
    return '<func>'
  }

  FunctionObject.prototype._call = function(arg, x) {
    var x2 = new ExecutionContext(Object.create(x.scope), x.store, x.pc)
    x2.scope[this.node.argName] = arg
    return this.node.body.execute(x2)
  }

  var FUN = {
    execute(context) {
      return new FunctionObject(this, context.scope) }}

  function run(ast) {
    return ast.execute(new ExecutionContext())
  }

  function runWithPC(ast, pc) {
    var x = new ExecutionContext()
    x.pc = pc
    return ast.execute(x)
  }

  return {
    __proto__: interpreter,
    APP, REF, DEREF, FUN,
    run,
    runWithPC,
  }
}())
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-module/ast-nodes>>
<<lambda-facet/facet-definitions>>
<<lambda-facet/interpreter>>

print(interpreter.run(app(fun('x', v('x')), c(42))) === 42)
print(interpreter.run(bot()) === interpreter.bottom)
print(interpreter.run(app(bot(), c(42))) === interpreter.bottom)
print(interpreter.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(interpreter.run(deref(bot())) === interpreter.bottom)

print(interpreter.runWithPC(
  app(fun('x', deref(v('x'))),
      ref(c(42))),
  [1]))
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true
: <1 ? 42 : BOT>

Look at all I’ve got to override!  For the AST objects, it’s okay, but for the
value objects we need to add the ~pc~ field to ~ExecutionContext~, and that
leads to redefining ~FunctionObject~, which in turn means we need to redefine
the FUN AST object just to update the binding.

Okay, maybe /subclassing/ ~FunctionObject~ was enough to do it.  But still, I
should not have to redefine FUN.  This is caused by the premature coupling
between ~FUN~ and ~FunctionObject~.  There are multiple ways to solve this
coupling: parameterize the ~interpreter~ module for the value objects:

: var interpreter = function(FunctionObject) { ... }

or define them outside the module and make an indirect call:

: return new valueObjects.FunctionObject(...)

or use a factory:

: return interpreter.mkFunctionObject(...)

All amount to the same, really.  It’s just adding a level of indirection to the
reference to ~FunctionObject~ in order to be able to change it in the facet
interpreter.  Note that factories are unnecessary in JavaScript, since we can
directly pass constructors as values.

Actually, we can see that the change to ~FunctionObject~ is just passing an
additional argument to ~ExecutionContext~, so we could make the
~ExecutionContext~ constructor inherit from a parent context to avoid redefining
~FunctionObject~.  Still, we would need to inject this new ~ExecutionContext~
into the new version of the interpreter.

But we need to adapt the standard interpreter for that to work.

* Lambda standard Mk3

#+NAME: lambda-standard-mk3/AST-nodes
#+BEGIN_SRC js
function bot() { return interpreter.BOT }
function c(e) { return {__proto__: interpreter.CONST, e} }
function v(e) { return {__proto__: interpreter.VAR, e} }
function fun(argName, body) { return {__proto__: interpreter.FUN, argName, body} }
function app(fun, arg) { return {__proto__: interpreter.APP, fun, arg} }
function ref(e) { return {__proto__: interpreter.REF, e} }
function deref(e) { return {__proto__: interpreter.DEREF, e} }
function assign(left, right) { return {__proto__: interpreter.ASSIGN, left, right} }
#+END_SRC

#+NAME: lambda-standard-mk3/AST-objects
#+BEGIN_SRC js
var BOT = {
  execute(context) {
    return interpreter.bottom }}

var CONST = {
  execute(context) {
    return this.e }}

var VAR = {
  execute(context) {
    return context.scope[this.e] }}

var FUN = {
  execute(context) {
    return new interpreter.FunctionObject(this, context.scope) }}

var APP = {
  execute(context) {
    var f = this.fun.execute(context)
    var a = this.arg.execute(context)
    return f._call(a, context) }}

var REF = {
  execute(context) {
    var r = this.e.execute(context)
    var a = context.store.add(r)
    return new interpreter.Address(a) }}

var DEREF = {
  execute(context) {
    var a = this.e.execute(context)
    return a.deref(context) }}
#+END_SRC

#+NAME: lambda-standard-mk3/value-objects
#+BEGIN_SRC js
var bottom = {
  toString() { return 'BOT' },
  _call(arg, context) { return this },
  deref(context) { return this },
}

function Address(a) { this.a = a }

Address.prototype.deref = function(context) {
  return context.store.retrieve(this.a)
}

function ExecutionContext(scope = {}, store = new Store()) {
  this.scope = scope
  this.store = store
}

function Store() { this.refs = [] }

Store.prototype.add = function(value) {
  this.refs.push(value)
  return this.refs.length - 1
}

Store.prototype.retrieve = function(addr) {
  return this.refs[addr]
}

function FunctionObject(node, scope) {
  this.node = node
  this.scope = scope
}

FunctionObject.prototype.toString = function() {
  return '<func>'
}

FunctionObject.prototype._call = function(arg, x) {
  var x2 = new interpreter.ExecutionContext(Object.create(x.scope), x.store)
  x2.scope[this.node.argName] = arg
  return this.node.body.execute(x2)
}
#+END_SRC

#+NAME: lambda-standard-mk3/interpreter
#+BEGIN_SRC js
var interpreter = (function(){
  <<lambda-standard-mk3/AST-objects>>
  <<lambda-standard-mk3/value-objects>>

  function run(node) {
    return node.execute(new interpreter.ExecutionContext())
  }

  return {
    BOT, CONST, VAR, FUN, APP, REF, DEREF,
    bottom, Address, ExecutionContext, Store, FunctionObject,
    run,
  }
}())
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-mk3/AST-objects>>
<<lambda-standard-mk3/value-objects>>
<<lambda-standard-mk3/interpreter>>
<<lambda-standard-mk3/AST-nodes>>

print(interpreter.run(app(fun('x', v('x')), c(42))) === 42)
print(interpreter.run(bot()) === interpreter.bottom)
print(interpreter.run(app(bot(), c(42))) === interpreter.bottom)
print(interpreter.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(interpreter.run(deref(bot())) === interpreter.bottom)
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true

And now, to add the facets changes.

#+NAME: lambda-facets-mk3/interpreter
#+BEGIN_SRC js
var interpreter = (function(){
  <<lambda-standard-mk3/interpreter>>

  var APP = {
    execute(context) {
      var f = this.fun.execute(context)
      var a = this.arg.execute(context)
      return evaluateEach(f, context, (f, x) => f._call(a, x)) }}
  interpreter.APP = APP

  var REF = {
    execute(context) {
      var r = this.e.execute(context)
      var a = context.store.add(r)
      return constructFacet(context.pc,
                            new interpreter.Address(a),
                            interpreter.bottom) }}
  interpreter.REF = REF

  var DEREF = {
    execute(context) {
      var a = this.e.execute(context)
      return evaluateEach(a, context, (a, x) => a.deref(context)) }}
  interpreter.DEREF = DEREF

  function ExecutionContext(scope = {}, store = new interpreter.Store(), pc = []) {
    this.scope = scope
    this.store = store
    this.pc = pc
  }
  interpreter.ExecutionContext = ExecutionContext

  // Save current value to avoid infinite recursion
  var FunctionObject = interpreter.FunctionObject
  function FunctionObjectF(...args) {
    FunctionObject.apply(this, args)
  }
  FunctionObjectF.prototype = Object.create(FunctionObject.prototype)

  FunctionObjectF.prototype._call = function(arg, x) {
    var x2 = new interpreter.ExecutionContext(Object.create(x.scope), x.store, x.pc)
    x2.scope[this.node.argName] = arg
    return this.node.body.execute(x2)
  }
  interpreter.FunctionObject = FunctionObjectF

  function run(ast) {
    return ast.execute(new interpreter.ExecutionContext())
  }
  interpreter.run = run

  function runWithPC(ast, pc) {
    var x = new interpreter.ExecutionContext()
    x.pc = pc
    return ast.execute(x)
  }


  return {
    __proto__: interpreter,
    runWithPC,
  }
}())
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-mk3/AST-nodes>>
<<lambda-facet/facet-definitions>>
<<lambda-facets-mk3/interpreter>>

print(interpreter.run(app(fun('x', v('x')), c(42))) === 42)
print(interpreter.run(bot()) === interpreter.bottom)
print(interpreter.run(app(bot(), c(42))) === interpreter.bottom)
print(interpreter.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(interpreter.run(deref(bot())) === interpreter.bottom)

print(interpreter.runWithPC(
  app(fun('x', deref(v('x'))),
      ref(c(42))),
  [1]))
#+END_SRC

#+RESULTS:
: true
: true
: true
: true
: true
: <1 ? 42 : BOT>

Now only the necessary lines are changed.  We could refactor ~ExecutionContext~
in the standard interpreter take a parent context and copy all its properties,
and avoid redefining the ~FunctionObject~.

The template to change the interpreter is:
1. Take the original interpreter (as it is a singleton, though it would be easy
   to change it to a factory: just don’t call the IIFE).
2. Define new pieces.
3. Change the references in the interpreter object.
4. Return the interpreter object (or an extended version, with additional
   exports).

This does not break encapsulation of the interpreter module (though you do have
to peek inside the module to know what to change).  But it’s still a bit
confusing since we have multiple objects that have /slightly different/
behavior, but have the same name...

Advantage of this method is that we can use it to change dynamically the
behavior of any instance of an interpreter.  And restore it.

An alternative would be to consider the facets evaluation as a different
~execute~ method, ~executeFacets~, which delegates to ~execute~ by default.
Then, have variants of AST node creators, and a ~runFacets~ that calls
~executeFacets~.  This way, we can create as many interpreters as there are
variants of evaluation.

We can still change the behavior of evaluation dynamically with a single
reference to the current interpreter (like a State pattern).

: interpreter = interpreterStd | interpreterFacets | ...

Remark: since we actually redefine what ~interpreter~ means, we are also
changing the meaning of programs created after this change through AST node
calls, but not of the programs created before this redefinition.  This is a bit
troublesome.

* Pure object interpreter
Actually, the indirection that we get by prefixing calls to the definitions made
inside the interpreter (~ExecutionContext~, ~FUN~, ...), we can obtain by using
getters.  That is, message passing instead of direct reference.

Since using a closure in the module pattern is just to prevent overriding the
definitions, and we /do need/ to override the definitions, we can use define the
interpreter as an object, which would make the overriding much more convenient
and straightforward.

#+NAME: lambda-standard-object/interpreter
#+BEGIN_SRC js
var interpreter = {
  BOT: {
    execute(context) {
      return this.interp.bottom }},

  CONST: {
    new(interp, e) { return {__proto__: this, interp, e} },
    execute(context) {
      return this.e }},

  VAR: {
    execute(context) {
      return context.scope[this.e] }},

  FUN: {
    execute(context) {
      return new this.interp.FunctionObject(this, context.scope) }},

  APP: {
    execute(context) {
      var f = this.fun.execute(context)
      var a = this.arg.execute(context)
      return f._call(a, context) }},

  REF: {
    execute(context) {
      var r = this.e.execute(context)
      var a = context.store.add(r)
      return new this.interp.Address(a) }},

  DEREF: {
    execute(context) {
      var a = this.e.execute(context)
      return a.deref(context) }},

  bottom: {
    _call(arg, context) { return this },
    deref(context) { return this },
    toString() { return 'BOT' },
  },

  Address: {
    new(a) { return {__proto__: this, a } },
    deref(context) { return context.store.retrieve(this.a) },
    toString() { return `#${this.a}` },
  },

  ExecutionContext: {
    new(scope = {}, store = this.interp.Store.new()) {
      return {__proto__: this, scope, store }
    },
  },

  Store: {
    new() {return {__proto__: this, refs: [] } },
    add(value) {
      this.refs.push(value)
      return this.refs.length - 1
    },
    retrieve(addr) { return this.refs[addr] },
  },

  FunctionObject: {
    new(node, scope) { return {__proto__: this, node, scope } },
    _call(arg, x) {
      var x2 = this.interp.ExecutionContext.new(Object.create(x.scope), x.store)
      x2.scope[this.node.argName] = arg
      return this.node.body.execute(x2)
    },
    toString() { return '<func>' },
  },

  run(node) {
    return node.execute(this.interp.ExecutionContext.new())
  },
}
#+END_SRC

#+BEGIN_SRC js :results output stderr
<<lambda-standard-mk3/AST-nodes>>
<<lambda-standard-object/interpreter>>

print(interpreter.run(app(fun('x', v('x')), c(42))) === 42)
print(interpreter.run(bot()) === interpreter.bottom)
print(interpreter.run(app(bot(), c(42))) === interpreter.bottom)
print(interpreter.run(app(fun('x', deref(v('x'))), ref(c(42)))) === 42)
print(interpreter.run(deref(bot())) === interpreter.bottom)
#+END_SRC

#+RESULTS:
: /tmp/babel-26894hMB/js-script-26894lNJ:81:4 TypeError: this.interp is undefined

So it’s actually not that difficult to change the interpreter if it follows a
style that is amenable to extension.  The trick is, of course, that we might
/not want/ or might not be /able to/ refactor the whole interpreter as we did
there.  In this case, we must find mechanisms to override the protection of the
module pattern.

** Sidebar: nested objects
Problem: ~CONST~ is an object defined inside ~std~, and so is
~ExecutionContext~.  A method inside ~CONST~ wants to refer to
~ExecutionContext~.

: std.ExecutionContext

does the job.  But, now we derive ~fct~ from ~std~ and override
~ExecutionContext~ in ~fct~.  Since we can call ~fct.CONST~, we would like it to
refer to ~fct.ExecutionContext~.  In other words, we would like ~fct.CONST~ to
follow the receiver.

If objects are not nested, this is the behavior we want:

#+BEGIN_SRC js :results output stderr
var std = {
  C() { return this.ExecutionContext() },
  ExecutionContext() { return 'ok' },
}

print(std.C())

var fct = {
  __proto__: std,
  ExecutionContext() { return 'super ok' }
}

print(fct.C())
#+END_SRC

#+RESULTS:
: ok
: super ok

Just plain dynamic binding: ~C~ is found on the prototype of ~fct~, but ~this~
is the receiver of the ~C~ call, which is ~fct~, so ~fct.ExecutionContext~ is
used in the end.

But we have nested objects, and using ~std~ does not work in ~fct.C~:

#+BEGIN_SRC js :results output stderr
var std = {
  C: {
    m() { return std.f() }},

  f() { return 'ok' },
}

print(std.C.m())

var fct = {
  __proto__: std,
  f() { return 'super ok' }
}

print(fct.C.m())
#+END_SRC

#+RESULTS:
: ok
: ok

For once, we could do it easily in Java with ~std.this~, which refers to the
instance of ~std~ associated with the instance of the nested class.

But in JavaScript, there is absolutely no difference between defining ~C~ inside
~std~ or outside.  Defining it inside does not implicitly define a link between
the two:

#+BEGIN_SRC js :results output stderr
var C = {m() { return std.f() }}

var std = {
  f() { return 'ok' },
  C: C,
}

print(std.C.m())

var fct = {
  __proto__: std,
  f() { return 'super ok' }
}

print(fct.C.m())
#+END_SRC

#+RESULTS:
: ok
: ok

In fact, ~std.C.m()~ and ~fct.C.m()~ and ~C.m()~ are totally equivalent calls.
If we want the first two to give different answers, ~C~ must be a different
object.  Or we can get tricky with getters.

#+BEGIN_SRC js :results output stderr
var C = {m() { return this.interp.f() }}

var std = {
  f() { return 'ok' },
  get C() {
    C.interp = this
    return C
  }
}

print(std.C.m())

var fct = {
  __proto__: std,
  f() { return 'super ok' }
}

print(fct.C.m())
#+END_SRC

#+RESULTS:
: ok
: super ok

As ~this~ is a hidden argument of function that is bound to the receiver, we can
view ~this.interp~ as an additional special argument, bound to the receiver of
the receiver.  We don’t have any syntax to pass this extra special argument, but
could make it explicit.

#+BEGIN_SRC js :results output stderr
var C = {m(interp) { return interp.f() }}

var std = {
  f() { return 'ok' },
  C: C,
}

print(std.C.m(std))

var fct = {
  __proto__: std,
  f() { return 'super ok' }
}

print(fct.C.m(fct))
#+END_SRC

#+RESULTS:
: ok
: super ok

But then, once again the ~std~ prefix is useless.

Rather than having to pass this argument to all calls to ~m~, if ~C~ has
instances, we can attach the interpreter at their creation:

#+BEGIN_SRC js :results output stderr
var std = {
  CONST: {
    new(interp, e) { return {__proto__: this, e, interp}},
    execute() { return this.interp.ExecutionContext.new() },
    toString() { return this.e },
  },

  ExecutionContext: {
    new() { return 'ok' }
  },
}

print(std.CONST.new(std, 42).execute())

function c(e) { return std.CONST.new(std, e) }

print(c(42).execute())

var fct = {
  __proto__: std,
  ExecutionContext: {
    new() { return 'super ok' }
  },
}

print(fct.CONST.new(fct, 42).execute())

function cF(e) { return fct.CONST.new(fct, e) }

print(cF(42).execute())
#+END_SRC

#+RESULTS:
: ok
: ok
: super ok
: super ok

This is quite explicit and straightforward (no tricks).  There could be an issue
of coherence: if multiple objects like ~C~ are defined inside ~std~, we would
like all their derivatives to point to the same interpreter object.  Here, this
is ensured only by using constructors like ~c~ and ~cF~.

So, in the end, I like the getter solution the best.  But I might not want to
define getters for every nested objects ... so is there a way to cut the work
with a constructor function?
