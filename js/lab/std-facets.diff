1,2c1,2
< function interpretNode(σ, θ, node) {
<   return rules[node.type](σ, θ, node);
---
> function interpretNode(σ, θ, pc, node) {
>   return rules[node.type](σ, θ, pc, node);
8a9,34
> function mk_facet(pc, v1, v2) {
>   if (pc.size === 0)
>     return v1;
> 
>   let [k, ...rest] = pc;
>   rest = new Set(rest);
> 
>   if (k > 0) {
>     return {
>       type: 'facet',
>       k,
>       vh: mk_facet(rest, v1, v2),
>       vl: v2
>     };
>   }
> 
>   else {
>     return {
>       type: 'facet',
>       k,
>       vh: v2,
>       vl: mk_facet(rest, v1, v2)
>     };
>   }
> }
> 
14c40
<   closure: function(σ, {x, e, θ}, v) {
---
>   closure: function(σ, pc, {x, e, θ}, v) {
17c43
<     return ↆ(σ, θ1, e);
---
>     return ↆ(σ, θ1, pc, e);
18a45,64
> 
>   facet: function(σ, pc, {k, vh, vl}, v2) {
>     if (pc.has(k)) {
>       return application_rules(σ, pc, vh, v2);
>     }
> 
>     else if (pc.has(-k)) {
>       return application_rules(σ, pc, vl, v2);
>     }
> 
>     else {
>       let pck = new Set(pc);
>       pck.add(k);
>       let [σ1, vh1] = application_rules(σ, pck, vh, v2);
>       let pcmk = new Set(pc);
>       pcmk.add(-k);
>       let [σ2, vl1] = application_rules(σ1, pcmk, vl, v2);
>       return [ σ2, mk_facet(k, vh1, vl1) ];
>     }
>   }
20a67
> 
26c73
<   address: function(σ, {a}) {
---
>   address: function(σ, {a}, pc) {
27a75,83
>   },
> 
>   facet: function(σ, {k, vh, vl}, pc) {
>     if (pc.has(k))
>       return deref(σ, vh, pc);
>     else if (pc.has(-k))
>       return deref(σ, vl, pc);
>     else
>       return mk_facet(k, deref(σ, vh, pc), deref(σ, vl, pc));
36c92
<   address: function(σ, {a}, v) {
---
>   address: function(σ, pc, {a}, v) {
38c94
<     σ2[a] = v;
---
>     σ2[a] = mk_facet(pc, v, σ[a]);
40a97,105
> 
>   facet: function(σ, pc, {k, vh, vl}, v) {
>     let pck = new Set(pc);
>     pck.add(k);
>     let σ1 = assign(σ, pck, vh, v);
>     let pcmk = new Set(pc);
>     pcmk.add(-k);
>     return assign(σ1, pcmk, vl, v);
>   }
44c109
<   c: function(σ, θ, {c}) {
---
>   c: function(σ, θ, pc, {c}) {
48c113
<   v: function(σ, θ, {x}) {
---
>   v: function(σ, θ, pc, {x}) {
52c117
<   fun: function(σ, θ, {x, e}) {
---
>   fun: function(σ, θ, pc, {x, e}) {
56,59c121,124
<   app: function(σ, θ, {e1, e2}) {
<     let [σ1, v1] = ↆ(σ, θ, e1);
<     let [σ2, v2] = ↆ(σ1, θ, e2);
<     return application_rules[v1.type](σ2, v1, v2);
---
>   app: function(σ, θ, pc, {e1, e2}) {
>     let [σ1, v1] = ↆ(σ, θ, pc, e1);
>     let [σ2, v2] = ↆ(σ1, θ, pc, e2);
>     return application_rules[v1.type](σ2, pc, v1, v2);
62,63c127,128
<   ref: function(σ, θ, {e}) {
<     let [σ1, v] = ↆ(σ, θ, e);
---
>   ref: function(σ, θ, pc, {e}) {
>     let [σ1, v] = ↆ(σ, θ, pc, e);
66c131
<     σ2[a] = v;
---
>     σ2[a] = mk_facet(pc, v, bottom);
70,72c135,137
<   deref: function(σ, θ, {e}) {
<     let [σ1, v] = ↆ(σ, θ, e);
<     return [ σ1, deref_rules[v.type](σ1, v) ];
---
>   deref: function(σ, θ, pc, {e}) {
>     let [σ1, v] = ↆ(σ, θ, pc, e);
>     return [ σ1, deref_rules[v.type](σ1, v, pc) ];
75,78c140,143
<   assign: function(σ, θ, {e1, e2}) {
<     let [σ1, v1] = ↆ(σ, θ, e1);
<     let [σ2, v2] = ↆ(σ1, θ, e2);
<     return [ assign_rules[v1.type](σ2, v1, v2), v2 ];
---
>   assign: function(σ, θ, pc, {e1, e2}) {
>     let [σ1, v1] = ↆ(σ, θ, pc, e1);
>     let [σ2, v2] = ↆ(σ1, θ, pc, e2);
>     return [ assign_rules[v1.type](σ2, pc, v1, v2), v2 ];
82c147
< function interpretProgram(AST, env, store) {
---
> function interpretProgram(AST, env, store, pc) {
85c150,151
<   return interpretNode(env, store, AST);
---
>   let pc = new Set(pc || []);
>   return interpretNode(env, store, pc, AST);
93c159
< });
---
> }, {},{},[1]);
